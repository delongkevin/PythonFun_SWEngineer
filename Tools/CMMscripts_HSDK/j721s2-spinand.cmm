; --------------------------------------------------------------------------------
; @Title: SPINAND FLASH Program script for the j721s2
; @Description:
; The SPINAND flash is connected to the OSPI_CS0 controller.
; Supported SPINAND flash memories:
; - W25N01JWxxxG
;
; SRAM:
; OSPI(controller) Base: 0x47040000
; OSPI memory mapped ADDRESS: 0x50000000
;
; Prerequisites: Switch Settings: CONFIG_SW[1] = ON (SW3.1 on common board)
;
; @Chip: AM752X, DRA829*, TDA4*
; @Board:
; @Author: CMO, JIM
; @Keywords: SPINAND
; @Copyright: (C) 1989-2022 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------

LOCAL &arg1
ENTRY &arg1
&arg1=STRing.UPpeR("&arg1")  // for example "PREPAREONLY"

LOCAL &pdd
&pdd=OS.PresentDemoDirectory()

&uniform="yes"
&use_pll2="yes"
&bare_metal="yes"              ; if R5 is not yet booted say yes
&iprobe="no"                   ; if TRACE32 logic analyzer hooked to r306 on SOM

IF "&iprobe"=="yes"
(
  NAME.RESET
  NAME.SET IProbe.00 FREQ
  IProbe.CSELect.IProbe FREQ     ; display ospi0_clk
  IProbe.Timing.IProbe.FREQ
  iprobe
  iprobe.off
)

; --------------------------------------------------------------------------------
LOCAL &OSPI_BASE &OSPI_MEMORY_BASE
&OSPI_BASE=0x47040000
&OSPI_MEMORY_BASE=0x50000000  ; flash contents memory mapped address

; --------------------------------------------------------------------------------
LOCAL &ospi
&ospi="yes"

; --------------------------------------------------------------------------------
; Open the master core(CM4) to configure system

 IF COMBIPROBE()||UTRACE()
   SYStem.CONFIG.CONNECTOR MIPI34 ; because of converter LA-3782

IF "&bare_metal"=="yes"
(
  TITLE "TRACE32 for ARM CM4-0 - MASTER"
  DO "../../x_gel_to_cmm/_J721S2_m4.cmm" CM4-0 PREPARE
  register
  DO "../../x_gel_to_cmm/J7AEP_SI.cmm"
  wait 1s
)

; Disable CR5-MCU lockstep
Data.Set EZAXI:0x45A50040 %Long 0x00000000

; --------------------------------------------------------------------------------
; Connect to MCU-CR5 to program flash
 TITLE "TRACE32 for ARM CR5-MCU - MASTER" 
 DO "../../x_gel_to_cmm/_J721S2_r5.cmm" R5-MCU AMP1
 SYStem.Option MemStatusCheck ON

; Enable GTC for debug timestamps, 0x3=freeze in debug halt
;  Data.Set EZAXI:0x00A90000 %LE %Long 0x1 ; GP=yes, HS-SE=no

 SCREEN.OFF
; ------------------------------------------------------------------------------
; Flash Controller Power & Clock Enable
GOSUB CLK_INIT
; ------------------------------------------------------------------------------
; Flash Pin Mux Configuration
GOSUB PIN_MUX
; ------------------------------------------------------------------------------
; Flash Controller Init
GOSUB OSPI_INIT
GOSUB CACHE_MMU_INIT

; ------------------------------------------------------------------------------
; Flash Read ID Test
GOSUB READ_ID_TEST

; ------------------------------------------------------------------------------
; Flash declaration
&pdd=OS.PresentDemoDirectory()

Break.RESet

FLASHFILE.RESet
if "&ospi"=="no"
( 
    FLASHFILE.Create 0x0--0x7FFFFFF   0x20000  ; W25N01JWxxxG, 128KB uniform blocks
    //FLASFILE.CONFIG <MCU_FSS0_OSPI0_CTRL>
    FLASHFILE.CONFIG &OSPI_BASE
    FLASHFILE.TARGET 0x41C00000++0x1FFF    E:0x41C02000++0x23FF   ~~/demo/arm/flash/byte/spinand2k6p_tiospi.bin   /KEEP  /DualPort

)
else
(
    FLASHFILE.Create 0x0--0x7FFFFFF   0x40000  ; W35N01JWxxxG, 256KB uniform blocks
    //FLASFILE.CONFIG <MCU_FSS0_OSPI0_CTRL>
    FLASHFILE.CONFIG &OSPI_BASE
    FLASHFILE.TARGET 0x41C00000++0x1FFF    E:0x41C02000++0x23FF   ~~/demo/arm/flash/byte/spinand4k6p_tiospi.bin   /KEEP  /DualPort

)

// Read FLASH Manufacturer and Device ID
FLASHFILE.GETID
;GOSUB FLASHFILE_ONFI_TEST  ;Read out the onfi registers in spinand flash

; ------------------------------------------------------------------------------
; SPINAND specific function to read memory
GOSUB FLASHFILE_CHECK_SPINAND_READMODE  ;Check BUF flag in the SR-2[3], it changes the spinand read method

//Unlock SPI NAND FLASH
FLASHFILE.UNLOCK 0x0--0x7FFFFFF

//End of the test prepareonly
IF "&arg1"=="PREPAREONLY"
  ENDDO

; ------------------------------------------------------------------------------
; Flash programming example

//Dump window for Serial FLASH
FLASHFILE.DUMP 0x0
;FLASHFILE.DUMP 0x0 /SPARE /Track

//Write Serial FLASH
FLASHFILE.ERASE 0x0--0x7FFFFFF

// Binaries folder location
&IMAGE_STAGING_DIR="..\..\..\.."

//Write Serial FLASH
// Load each required image here (in ascending location):

    ;LOAD SBL
if "&ospi"=="yes"
( 
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/sbl_ospi_img_mcu1_0_release.tiimage 0x0
	FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/nand_spi_patterns.bin 0x46C0000
)
else
(
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/sbl_qspi_img_mcu1_0_release.tiimage 0x0
	FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/nand_spi_patterns.bin 0x7F800
)
	
IF "&HS_device"=="GP"
(
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/tifs.bin    0x80000
	FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/L2H4060Hsm.appimage  0xc0000
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/BootManager_SecureBoot/DemoBm.bin  0x200000
)
else
(
    FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/tifs-hs-enc.bin 0x80000
    FLASHFILE.LOAD &IMAGE_STAGING_DIR/HSM/HSMBoot.signed  0xc0000 
)

FLASHFILE.LOAD &IMAGE_STAGING_DIR/Bootloader/DemoFbl.bin 0x280000

FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_app_mcu1_0_EOL.hex //App size: 3MB 
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_lateapp1_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_lateapp2_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_atf_optee_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_ifs_qnx_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_extended_key_ring_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_cal_info_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/NAND/Signed_SecCert_EOL.hex
FLASHFILE.LOAD &IMAGE_STAGING_DIR/EOL/EOL.bin 0x6C60000
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/NAND/CertStoreNvM_Dump.hex
//Reset device
PRINT "Please power-cycle the board after flash program is complete"

ENDDO


READ_ID_TEST:
(
  ; In case of errors you can try to read the ID via:
  ; GOSUB READ_ID_TEST
  ;
  ; Check the output of the AREA window.
  ; Expected output ID:
  ; 0xFF (Dummy)
  ; 0xEF (Manufacture)
  ; 0xBC
  ; 0x21

  LOCAL &rdata
  &CTRLREG=&OSPI_BASE+0x090
  &RXDATA0=&OSPI_BASE+0x0A0
  &RXDATA1=&OSPI_BASE+0x0A4

  &cmd=0x9f<<24.     //cmd
  &rd=0x1<<23.       //rd data enable
  &rd_num=0x7<<20.   //7+1==8bytes, max
  &cmd_exec=0x1      //cmd execution

  Data.Set EZAXI:&CTRLREG %LE %Long (&cmd|&cmd_exec|&rd_num|&rd)   ;write cmd + write data
  WAIT 100.ms

  &rdata=Data.Long(EZAXI:&RXDATA0)  ;read lower  , 8byte fifo
  PRINT "1st 0x" (&rdata)&0xFF " (Dummy)"      ; //RXFIFO0
  PRINT "2nd 0x" (&rdata>>8.)&0xFF " (Manufacture)"
  PRINT "3rd 0x" (&rdata>>16.)&0xFF " (Device ID)[15:8]"
  PRINT "4th 0x" (&rdata>>24.)&0xFF " (Device ID)[7:0]"
  &rdata=Data.Long(EZAXI:&RXDATA1)  ;read upper , 8byte fifo
  ;PRINT "5th 0x" (&rdata)&0xFF
  ;PRINT "6th 0x" (&rdata>>8.)&0xFF
  ;PRINT "7th 0x" (&rdata>>16.)&0xFF
  ;PRINT "8th 0x" (&rdata>>24.)&0xFF

  RETURN
)


FLASHFILE_ONFI_TEST:
(
  FLASHFILE.GETONFI /VM

  PRINT "A page size: " %Decimal Data.Long(VM:0x50) "./" Data.Long(VM:0x54) ".Bytes (main/spare)"
  PRINT "A block size: 0x" Data.Long(VM:0x50)*Data.Long(VM:0x5C)  " (" %Decimal Data.Long(VM:0x5C) ".Pages)"
  PRINT "A device size: 0x" Data.Long(VM:0x50)*Data.Long(VM:0x5C)*Data.Long(VM:0x60)  " Bytes"
  RETURN
)


FLASHFILE_CHECK_SPINAND_READMODE:
(
  //The Buffer Read Mode (BUF=1) requires a Column Address to start outputting the existing data inside
  //the Data Buffer, and once it reaches the end of the data buffer (Byte 2,111), DO (IO1) pin will become
  //high-Z state.
  //The Continuous Read Mode (BUF=0) doesn��t require the starting Column Address. The device will
  //always start output the data from the first column (Byte 0) of the Data buffer, and once the end of the
  //data buffer (Byte 2,048) is reached, the data output will continue through the next memory page.

  //2048+64, Buffer Read Mode (BUF=1), bcz the OSPI RX buffer is not large enough (Not A nand page size)
  FLASHFILE.SPI.CMD 0x0F 0xB0 /READ 0x4 VM:0
  IF Data.Byte(VM:0x0)!=0x18
  (
    FLASHFILE.SPI.CMD 0x1F 0xB0 0x18   ;Set ECC[4]=1, BUF[3]=1 in Status Register-2
  )
  RETURN
)


OSPI_INIT:
(
  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x0
  Data.Set EZAXI:&OSPI_BASE+0x4  %LE %Long 0x00000013 ; 4B Addr Read
  Data.Set EZAXI:&OSPI_BASE+0x8  %LE %Long 0x00000012 ; 4B Addr Write

  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x80800000
  Data.Set EZAXI:&OSPI_BASE+0x14 %LE %Long 0x1003; 4B Address mode, 3B Addr: 0x1002
  Data.Set EZAXI:&OSPI_BASE+0x10 %LE %Long 0x21

  Data.Set EZAXI:&OSPI_BASE+0x1C %LE %Long 0xFFFFFFFF
  //Data.Set EZAXI:&OSPI_BASE+0xC  %LE %Long (0xFF<<16.)|(0xFF<<8.) ; !!!!! OSPI_DEV_DELAY_REG because of writing !!!!!
  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x00000081|(0x1<<19.)|(0xE<<10.) ; 0x1==baudrate_div4, enable usage of OSPI_CS0
  Data.Set EZAXI:&OSPI_BASE+0x1C %LE %Long 0x04000000 ;ospi_setdirectcutoff, end of the flash address

  RETURN
)

PIN_MUX:
(
  ;MMR_unlock
  Data.Set EZAXI:0x4301D008 %Long 0x68EF3490  ;CTRLMMR_WKUP_LOCK7_KICK0
  Data.Set EZAXI:0x4301D00C %Long 0xD172BC5A

  Data.Set EZAXI:0x4301C000 %Long 0x00040000   ; D19: CTRLMMR_WKUP_PADCONFIG0 MCU_OSPI0_CLK
  Data.Set EZAXI:0x4301C004 %Long 0x00040000   ; E20: MCU_OSPI0_LBCLKO
  Data.Set EZAXI:0x4301C008 %Long 0x00040000   ; E18: MCU_OSPI0_DQS
  Data.Set EZAXI:0x4301C00C %Long 0x00040000   ; C19: MCU_OSPI0_D0
  Data.Set EZAXI:0x4301C010 %Long 0x00040000   ; F16: MCU_OSPI0_D1
  Data.Set EZAXI:0x4301C014 %Long 0x00040000   ; G15: MCU_OSPI0_D2
  Data.Set EZAXI:0x4301C018 %Long 0x00040000   ; F18: MCU_OSPI0_D3
  Data.Set EZAXI:0x4301C01C %Long 0x00040000   ; E19: MCU_OSPI0_D4
  Data.Set EZAXI:0x4301C020 %Long 0x00040000   ; G19: MCU_OSPI0_D5
  Data.Set EZAXI:0x4301C024 %Long 0x00040000   ; F19: MCU_OSPI0_D6
  Data.Set EZAXI:0x4301C028 %Long 0x00040000   ; F20: MCU_OSPI0_D7
  Data.Set EZAXI:0x4301C02C %Long 0x00040000   ; F15: MCU_OSPI0_CSn0
  Data.Set EZAXI:0x4301C030 %Long 0x00040000   ; G17: MCU_OSPI0_CSn1
  Data.Set EZAXI:0x4301C038 %Long 0x00040001   ; F14: MCU_OSPI0_CSn2
  Data.Set EZAXI:0x4301C03C %Long 0x00040001   ; F17: MCU_OSPI0_CSn3
  RETURN
)

CLK_INIT:
(
  Data.Set EZAXI:0x40F09008 %Long 0x68EF3490  ; CTRLMMR_MCU_LOCK2_KICK0
  Data.Set EZAXI:0x40F0900C %Long 0xD172BC5A

  Data.Set EZAXI:0x40d01010  %Long 0x68EF3490  ;MCU_PLL1_KICK0
  Data.Set EZAXI:0x40d01014  %Long 0xD172BC5A  ;MCU_PLL1_KICK1

  wait 1.ms

  IF "&use_pll2"=="yes"
  (
    Data.Set EZAXI:0x40D02090 %Long 0x0000800b  ; MCU_PLL2_HSDIV_CTRL4 --> 166MHz
    wait 1.ms
    Data.Set EZAXI:0x40F08030  %Long 0x1         ;CTRLMMR_MCU_OSPI0_CLKSEL, 2h - MCU_PLL2_HSDIV4_CLKOUT
  )
  ELSE
  (
    ;freq: PLL1 (2.4G) -> HSDIV4 (/5+1) -> 400Mhz --> BAUD/x
    Data.Set EZAXI:0x40D01090  %Long 0x8005      ;MCU_PLL1_HSDIV_CTRL4
    wait 1.ms
    Data.Set EZAXI:0x40F08030  %Long 0x0         ;CTRLMMR_MCU_OSPI0_CLKSEL, 0h - MCU_PLL1_HSDIV4_CLKOUT
  )
  wait 1.ms
  RETURN
)


CACHE_MMU_INIT:
(
  PRIVATE &i &tmpReg

  ; Enable MPU and disable I and D caches
  &tmpReg=Data.Long(C15:0x1)
  &tmpReg=&tmpReg|0x1             ; enable MPU
  &tmpReg=(&tmpReg&(~(0x1<<2.)))  ; disable D cache
  &tmpReg=(&tmpReg&(~(0x1<<12.))) ; disable I cache
  Data.Set C15:0x1 %Long &tmpReg

  ; Configure small region setup for flash programming
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x016 %Long 0x00000000 ; set default
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x216 %Long 0x0000003F
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x416 %Long 0x00001310
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x016 %Long 0x50000000 ; setup flash window
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x216 %Long 0x00000035
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x416 %Long 0x00001301
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x016 %Long 0x41C00000 ; setup buffer space
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x216 %Long 0x00000027
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x416 %Long 0x0000030C
  ; Reset all other MPU regions
  &i=3.
  WHILE &i<16.
  (
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x016 %Long 0x0
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x216 %Long 0x0
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x416 %Long 0x0
    &i=&i+1.
  )

  RETURN
)

// detect the flash address mode by the internal flash register (0x0080_0003)
// CR2V : should come 0x08(3B) or 0x88(4B)
SPI_4B_ADDRMODE_ENABLE:
(
  SILENT.FLASH.SPI.CMD 1.  0x06
  SILENT.FLASH.SPI.CMD 1.  0x71 0x80 0x00 0x03 0x88   ; write  0x88 to CR2V , switch 3B->4B address mode

  Data.Set VM:0x0--0xFF %Long 0x0
  SILENT.FLASH.SPI.CMD 1.  0x65 0x00 0x80 0x00 0x03 0x0    /READ 0x4 vm:0x0 ;4Bytes Address mode
  &regData=Data.Byte(vm:0x0)
  IF &regData!=0x88
  (
    PRINT "We expect 0x08 latency(dummy) cycles but we got the dummy cycle 0x" %Hex &regData
    ENDDO
  )
  RETURN
)
