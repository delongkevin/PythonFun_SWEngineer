; --------------------------------------------------------------------------------
; @Title: SPINAND FLASH Program script with Error Handling
; @Description:
; This script flashes binaries to the SPINAND memory and handles errors by jumping to a subroutine.
; --------------------------------------------------------------------------------

LOCAL &arg1 &error_occurred
ENTRY &arg1
&arg1=STRing.UPpeR("&arg1")
&error_occurred=0  // for example "PREPAREONLY"

LOCAL &pdd
&pdd=OS.PresentDemoDirectory()

&uniform="yes"
&use_pll2="yes"
&bare_metal="yes"              ; if R5 is not yet booted say yes
&iprobe="no"                   ; if TRACE32 logic analyzer hooked to r306 on SOM

IF "&iprobe"=="yes"
(
  NAME.RESET
  NAME.SET IProbe.00 FREQ
  IProbe.CSELect.IProbe FREQ     ; display ospi0_clk
  IProbe.Timing.IProbe.FREQ
  iprobe
  iprobe.off
)

LOCAL &OSPI_BASE &OSPI_MEMORY_BASE
&OSPI_BASE=0x47040000
&OSPI_MEMORY_BASE=0x50000000  ; flash contents memory mapped address

LOCAL &ospi
&ospi="yes"

; Open the master core(CM4) to configure system

IF COMBIPROBE()||UTRACE()
   SYStem.CONFIG.CONNECTOR MIPI34 ; because of converter LA-3782

IF "&bare_metal"=="yes"
(
  TITLE "TRACE32 for ARM CM4-0 - MASTER"
  DO "C:/JS/ws/develop/sw/Release/Tools/CMMscripts_HSDK/x_gel_to_cmm/_J721S2_m4.cmm" CM4-0 PREPARE
  register
  DO "C:/JS/ws/develop/sw/Release/Tools/CMMscripts_HSDK/x_gel_to_cmm/J7AEP_SI.cmm"
  wait 1s
)

; Disable CR5-MCU lockstep
Data.Set EZAXI:0x45A50040 %Long 0x00000000

; Connect to MCU-CR5 to program flash
TITLE "TRACE32 for ARM CR5-MCU - MASTER" 
DO "C:/JS/ws/develop/sw/Release/Tools/CMMscripts_HSDK/x_gel_to_cmm/_J721S2_r5.cmm" R5-MCU AMP1
SYStem.Option MemStatusCheck ON

; Enable GTC for debug timestamps, 0x3=freeze in debug halt
;  Data.Set EZAXI:0x00A90000 %LE %Long 0x1 ; GP=yes, HS-SE=no

SCREEN.OFF

; Flash Controller Power & Clock Enable
GOSUB CLK_INIT

; Flash Pin Mux Configuration
GOSUB PIN_MUX

; Flash Controller Init
GOSUB OSPI_INIT
GOSUB CACHE_MMU_INIT

; Flash Read ID Test
GOSUB READ_ID_TEST

; Flash declaration
&pdd=OS.PresentDemoDirectory()

Break.RESet
FLASHFILE.RESet

; Enable error handler
ON ERROR GOSUB HANDLE_ERROR

IF "&ospi"=="no"
( 
    FLASHFILE.Create 0x0--0x7FFFFFF   0x20000  ; W25N01JWxxxG, 128KB uniform blocks
    FLASHFILE.CONFIG &OSPI_BASE
    FLASHFILE.TARGET 0x41C00000++0x1FFF E:0x41C02000++0x23FF ~~/demo/arm/flash/byte/spinand2k6p_tiospi.bin /KEEP /DualPort
)
ELSE
(
    FLASHFILE.Create 0x0--0x7FFFFFF   0x40000  ; W35N01JWxxxG, 256KB uniform blocks
    FLASHFILE.CONFIG &OSPI_BASE
    FLASHFILE.TARGET 0x41C00000++0x1FFF E:0x41C02000++0x23FF ~~/demo/arm/flash/byte/spinand4k6p_tiospi.bin /KEEP /DualPort
)

; Read FLASH Manufacturer and Device ID
FLASHFILE.GETID

; SPINAND specific function to read memory
GOSUB FLASHFILE_CHECK_SPINAND_READMODE  ; Check BUF flag in the SR-2[3], it changes the spinand read method

; Unlock SPI NAND FLASH
FLASHFILE.UNLOCK 0x0--0x7FFFFFF

; End of the test if the argument is "PREPAREONLY"
IF "&arg1"=="PREPAREONLY"
  ENDDO

; ------------------------------------------------------------------------------
; Flash programming example with error handling

; Dump window for Serial FLASH
FLASHFILE.DUMP 0x0

; Erase Serial FLASH
FLASHFILE.ERASE 0x0--0x7FFFFFF

; Binaries folder location
&IMAGE_STAGING_DIR="C:/JS/ws/develop/sw/Release"

; Write Serial FLASH and load each required image here (in ascending location):
PRinTer.FILE C:/JS/ws/develop/sw/Release/flashlog.txt ASCIIE 


IF "&ospi"=="yes"
( 
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/sbl_ospi_img_mcu1_0_release.tiimage 0x0
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/nand_spi_patterns.bin 0x46C0000
)
ELSE
(
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/sbl_qspi_img_mcu1_0_release.tiimage 0x0
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/nand_spi_patterns.bin 0x7F800
)

IF "&HS_device"=="GP"
(
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/tifs.bin 0x80000
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/L2H5250Hsm.appimage 0xc0000
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/BootManager_SecureBoot/DemoBm.bin 0x200000
)
ELSE
(
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/NAND/tifs-hs-enc.bin 0x80000
  FLASHFILE.LOAD &IMAGE_STAGING_DIR/HSM/HSMBoot.signed 0xc0000 
)

; Flash additional files
FLASHFILE.LOAD &IMAGE_STAGING_DIR/Bootloader/DemoFbl.bin 0x280000
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_app_mcu1_0_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_lateapp1_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_lateapp2_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_atf_optee_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_ifs_qnx_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_extended_key_ring_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/out_UnSigned_EOL_Hex/UnSigned_cal_info_EOL.hex
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/EOL/Signed_SecCert_EOL.hex
FLASHFILE.LOAD &IMAGE_STAGING_DIR/EOL/EOL.bin 0x6C60000
FLASHFILE.LOAD.IntelHex &IMAGE_STAGING_DIR/NAND/CertStoreNvM_Dump.hex

;check again (restore)
ON ERROR INHERIT

IF &error_occurred==0
(
  PRINT "All files loaded successfully. Flashing process completed."
  PRINT "Please power-cycle the board after flash program is complete"
)
ELSE
(
  PRINT "Error occurred during flashing process. See log file for details."
)

CLOSE_TRACE32:
  ; Save log and quit
  WinPRT W000 /ALL
  PRINT "Closing Trace32.."
  wait 1s
  QUIT

HANDLE_ERROR:
  &error_occurred=1  // Set error flag
  PRINT %ERROR "Unexpected error during flashing."
  GOTO CLOSE_TRACE32  // Jump to the closing section




READ_ID_TEST:
(
  LOCAL &rdata
  &CTRLREG=&OSPI_BASE+0x090
  &RXDATA0=&OSPI_BASE+0x0A0
  &RXDATA1=&OSPI_BASE+0x0A4

  &cmd=0x9f<<24.     //cmd
  &rd=0x1<<23.       //rd data enable
  &rd_num=0x7<<20.   //7+1==8bytes, max
  &cmd_exec=0x1      //cmd execution

  Data.Set EZAXI:&CTRLREG %LE %Long (&cmd|&cmd_exec|&rd_num|&rd)   ;write cmd + write data
  WAIT 100.ms

  &rdata=Data.Long(EZAXI:&RXDATA0)  ;read lower  , 8byte fifo
  PRINT "1st 0x" (&rdata)&0xFF " (Dummy)"      ; //RXFIFO0
  PRINT "2nd 0x" (&rdata>>8.)&0xFF " (Manufacture)"
  PRINT "3rd 0x" (&rdata>>16.)&0xFF " (Device ID)[15:8]"
  PRINT "4th 0x" (&rdata>>24.)&0xFF " (Device ID)[7:0]"
  &rdata=Data.Long(EZAXI:&RXDATA1)  ;read upper , 8byte fifo

  RETURN
)


FLASHFILE_ONFI_TEST:
(
  FLASHFILE.GETONFI /VM

  PRINT "A page size: " %Decimal Data.Long(VM:0x50) "./" Data.Long(VM:0x54) ".Bytes (main/spare)"
  PRINT "A block size: 0x" Data.Long(VM:0x50)*Data.Long(VM:0x5C)  " (" %Decimal Data.Long(VM:0x5C) ".Pages)"
  PRINT "A device size: 0x" Data.Long(VM:0x50)*Data.Long(VM:0x5C)*Data.Long(VM:0x60)  " Bytes"
  RETURN
)


FLASHFILE_CHECK_SPINAND_READMODE:
(
  FLASHFILE.SPI.CMD 0x0F 0xB0 /READ 0x4 VM:0
  IF Data.Byte(VM:0x0)!=0x18
  (
    FLASHFILE.SPI.CMD 0x1F 0xB0 0x18   ;Set ECC[4]=1, BUF[3]=1 in Status Register-2
  )
  RETURN
)


OSPI_INIT:
(
  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x0
  Data.Set EZAXI:&OSPI_BASE+0x4  %LE %Long 0x00000013 ; 4B Addr Read
  Data.Set EZAXI:&OSPI_BASE+0x8  %LE %Long 0x00000012 ; 4B Addr Write

  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x80800000
  Data.Set EZAXI:&OSPI_BASE+0x14 %LE %Long 0x1003; 4B Address mode, 3B Addr: 0x1002
  Data.Set EZAXI:&OSPI_BASE+0x10 %LE %Long 0x21

  Data.Set EZAXI:&OSPI_BASE+0x1C %LE %Long 0xFFFFFFFF
  //Data.Set EZAXI:&OSPI_BASE+0xC  %LE %Long (0xFF<<16.)|(0xFF<<8.) ; !!!!! OSPI_DEV_DELAY_REG because of writing !!!!!
  Data.Set EZAXI:&OSPI_BASE+0x0  %LE %Long 0x00000081|(0x1<<19.)|(0xE<<10.) ; 0x1==baudrate_div4, enable usage of OSPI_CS0
  Data.Set EZAXI:&OSPI_BASE+0x1C %LE %Long 0x04000000 ;ospi_setdirectcutoff, end of the flash address

  RETURN
)

PIN_MUX:
(
  ;MMR_unlock
  Data.Set EZAXI:0x4301D008 %Long 0x68EF3490  ;CTRLMMR_WKUP_LOCK7_KICK0
  Data.Set EZAXI:0x4301D00C %Long 0xD172BC5A

  Data.Set EZAXI:0x4301C000 %Long 0x00040000   ; D19: CTRLMMR_WKUP_PADCONFIG0 MCU_OSPI0_CLK
  Data.Set EZAXI:0x4301C004 %Long 0x00040000   ; E20: MCU_OSPI0_LBCLKO
  Data.Set EZAXI:0x4301C008 %Long 0x00040000   ; E18: MCU_OSPI0_DQS
  Data.Set EZAXI:0x4301C00C %Long 0x00040000   ; C19: MCU_OSPI0_D0
  Data.Set EZAXI:0x4301C010 %Long 0x00040000   ; F16: MCU_OSPI0_D1
  Data.Set EZAXI:0x4301C014 %Long 0x00040000   ; G15: MCU_OSPI0_D2
  Data.Set EZAXI:0x4301C018 %Long 0x00040000   ; F18: MCU_OSPI0_D3
  Data.Set EZAXI:0x4301C01C %Long 0x00040000   ; E19: MCU_OSPI0_D4
  Data.Set EZAXI:0x4301C020 %Long 0x00040000   ; G19: MCU_OSPI0_D5
  Data.Set EZAXI:0x4301C024 %Long 0x00040000   ; F19: MCU_OSPI0_D6
  Data.Set EZAXI:0x4301C028 %Long 0x00040000   ; F20: MCU_OSPI0_D7
  Data.Set EZAXI:0x4301C02C %Long 0x00040000   ; F15: MCU_OSPI0_CSn0
  Data.Set EZAXI:0x4301C030 %Long 0x00040000   ; G17: MCU_OSPI0_CSn1
  Data.Set EZAXI:0x4301C038 %Long 0x00040001   ; F14: MCU_OSPI0_CSn2
  Data.Set EZAXI:0x4301C03C %Long 0x00040001   ; F17: MCU_OSPI0_CSn3
  RETURN
)

CLK_INIT:
(
  Data.Set EZAXI:0x40F09008 %Long 0x68EF3490  ; CTRLMMR_MCU_LOCK2_KICK0
  Data.Set EZAXI:0x40F0900C %Long 0xD172BC5A

  Data.Set EZAXI:0x40d01010  %Long 0x68EF3490  ;MCU_PLL1_KICK0
  Data.Set EZAXI:0x40d01014  %Long 0xD172BC5A  ;MCU_PLL1_KICK1

  wait 1.ms

  IF "&use_pll2"=="yes"
  (
    Data.Set EZAXI:0x40D02090 %Long 0x0000800b  ; MCU_PLL2_HSDIV_CTRL4 --> 166MHz
    wait 1.ms
    Data.Set EZAXI:0x40F08030  %Long 0x1         ;CTRLMMR_MCU_OSPI0_CLKSEL, 2h - MCU_PLL2_HSDIV4_CLKOUT
  )
  ELSE
  (
    ;freq: PLL1 (2.4G) -> HSDIV4 (/5+1) -> 400Mhz --> BAUD/x
    Data.Set EZAXI:0x40D01090  %Long 0x8005      ;MCU_PLL1_HSDIV_CTRL4
    wait 1.ms
    Data.Set EZAXI:0x40F08030  %Long 0x0         ;CTRLMMR_MCU_OSPI0_CLKSEL, 0h - MCU_PLL1_HSDIV4_CLKOUT
  )
  wait 1.ms
  RETURN
)


CACHE_MMU_INIT:
(
  PRIVATE &i &tmpReg

  ; Enable MPU and disable I and D caches
  &tmpReg=Data.Long(C15:0x1)
  &tmpReg=&tmpReg|0x1             ; enable MPU
  &tmpReg=(&tmpReg&(~(0x1<<2.)))  ; disable D cache
  &tmpReg=(&tmpReg&(~(0x1<<12.))) ; disable I cache
  Data.Set C15:0x1 %Long &tmpReg

  ; Configure small region setup for flash programming
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x016 %Long 0x00000000 ; set default
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x216 %Long 0x0000003F
  PER.Set.SaveIndex C15:0x026 %Long 0x0 C15:0x416 %Long 0x00001310
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x016 %Long 0x50000000 ; setup flash window
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x216 %Long 0x00000035
  PER.Set.SaveIndex C15:0x026 %Long 0x1 C15:0x416 %Long 0x00001301
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x016 %Long 0x41C00000 ; setup buffer space
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x216 %Long 0x00000027
  PER.Set.SaveIndex C15:0x026 %Long 0x2 C15:0x416 %Long 0x0000030C
  ; Reset all other MPU regions
  &i=3.
  WHILE &i<16.
  (
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x016 %Long 0x0
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x216 %Long 0x0
    PER.Set.SaveIndex C15:0x026 %Long &i C15:0x416 %Long 0x0
    &i=&i+1.
  )

  RETURN
)

// detect the flash address mode by the internal flash register (0x0080_0003)
// CR2V : should come 0x08(3B) or 0x88(4B)
SPI_4B_ADDRMODE_ENABLE:
(
  SILENT.FLASH.SPI.CMD 1.  0x06
  SILENT.FLASH.SPI.CMD 1.  0x71 0x80 0x00 0x03 0x88   ; write  0x88 to CR2V , switch 3B->4B address mode

  Data.Set VM:0x0--0xFF %Long 0x0
  SILENT.FLASH.SPI.CMD 1.  0x65 0x00 0x80 0x00 0x03 0x0    /READ 0x4 vm:0x0 ;4Bytes Address mode
  &regData=Data.Byte(vm:0x0)
  IF &regData!=0x88
  (
    PRINT "We expect 0x08 latency(dummy) cycles but we got the dummy cycle 0x" %Hex &regData
    ENDDO
  )
  RETURN
)


