LOCAL &function &args
ENTRY &function %LINE &args
// --  ------------------------------------------------------------------------- 
// --  J7AEP_eFuse.gel                                                            
// --  J7AEP Bring-Up GEL file for the SVB (eFuse scan).                          
// --  History:                                                                  
// --  V0.1: 10/11/2021 ......................................... initial version 
// --  Copyright (c) 2019, Texas Instruments Incorporated
// --  * All rights reserved.
// --  *
// --  * Redistribution and use in source and binary forms, with or without
// --  * modification, are permitted provided that the following conditions
// --  * are met:
// --  *
// --  * *  Redistributions of source code must retain the above copyright
// --  *    notice, this list of conditions and the following disclaimer.
// --  *
// --  * *  Redistributions in binary form must reproduce the above copyright
// --  *    notice, this list of conditions and the following disclaimer in the
// --  *    documentation and/or other materials provided with the distribution.
// --  *
// --  * *  Neither the name of Texas Instruments Incorporated nor the names of
// --  *    its contributors may be used to endorse or promote products derived
// --  *    from this software without specific prior written permission.
// --  *
// --  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// --  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// --  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// --  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// --  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// --  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// --  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// --  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// --  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// --  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// --  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// --  ************************************************************************* 
// -- Register definitions
LOCAL &__CSL_CTRL_EFUSE0_BASE
&__CSL_CTRL_EFUSE0_BASE=(0x300000)
LOCAL &__CSL_CTRL_EFUSE0_SIZE
&__CSL_CTRL_EFUSE0_SIZE=(0x100)
LOCAL &__MCU_EFUSE0_BASE
&__MCU_EFUSE0_BASE=(0x40c00000)
LOCAL &__MCU_EFUSE0_SIZE
&__MCU_EFUSE0_SIZE=(0x100)
// -- Security Manager Registers (accessible from DMSC only)
// -- Sec Manager Base Address
LOCAL &__CSL_WKUP_DMSC0_SECMGR_BASE
&__CSL_WKUP_DMSC0_SECMGR_BASE=(0x44234000)
// -- Sec Manager MMR Map
LOCAL &__SEC_MGR_REVISION
&__SEC_MGR_REVISION=(0x0)
LOCAL &__SEC_MGR_SYSTEM_STAT
&__SEC_MGR_SYSTEM_STAT=(0x100)
// -- MMR DEFINITIONS
// -- Main Control MMR Base
LOCAL &__CSL_MAIN_CTRL_MMR0_CFG0_BASE
&__CSL_MAIN_CTRL_MMR0_CFG0_BASE=(0x100000)
LOCAL &__CSL_MAIN_CTRL_MMR0_CFG0_SIZE
&__CSL_MAIN_CTRL_MMR0_CFG0_SIZE=(0x20000)
// -- MCU Control MMR Base
LOCAL &__PLL_MMR0_CFG_BASE
&__PLL_MMR0_CFG_BASE=(0x40D00000)
LOCAL &__CSL_MCU_CTRL_MMR0_CFG0_BASE
&__CSL_MCU_CTRL_MMR0_CFG0_BASE=(0x40f00000)
LOCAL &__CSL_MCU_CTRL_MMR0_CFG0_SIZE
&__CSL_MCU_CTRL_MMR0_CFG0_SIZE=(0x20000)
// -- WKUP Control MMR Base
LOCAL &__CSL_WKUP_CTRL_MMR0_CFG0_BASE
&__CSL_WKUP_CTRL_MMR0_CFG0_BASE=(0x43000000)
LOCAL &__CSL_WKUP_CTRL_MMR0_CFG0_SIZE
&__CSL_WKUP_CTRL_MMR0_CFG0_SIZE=(0x20000)
// -- Main Control MMR Registers
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_MAIN_DEVSTAT
&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_DEVSTAT=(0x00000030)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_MAIN_BOOTCFG
&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_BOOTCFG=(0x00000034)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_0
&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_0=(0x00000040)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_1
&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_1=(0x00000044)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE0
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE0=(0x00000300)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE1
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE1=(0x00000304)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE2
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE2=(0x00000308)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE3
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE3=(0x0000030C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM0
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM0=(0x00004480)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM1
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM1=(0x00004484)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM2
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM2=(0x00004488)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM3
&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM3=(0x0000448C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE0
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE0=(0x00010500)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE1
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE1=(0x00010504)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE2
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE2=(0x00010508)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE3
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE3=(0x0001050C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE4
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE4=(0x00010510)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE5
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE5=(0x00010514)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE6
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE6=(0x00010518)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE7
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE7=(0x0001051C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE8
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE8=(0x00010520)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE9
&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE9=(0x00010524)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_ICSSG0_DISABLE_STAT
&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG0_DISABLE_STAT=(0x00000050)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_ICSSG1_DISABLE_STAT
&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG1_DISABLE_STAT=(0x00000054)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_ICSSG2_DISABLE_STAT
&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG2_DISABLE_STAT=(0x00000058)
// -- Main Control MMR Lock Registers
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK0_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK0_KICK0=(0x00001008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK0_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK0_KICK1=(0x0000100C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK1_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK1_KICK0=(0x00005008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK1_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK1_KICK1=(0x0000500C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK0=(0x00009008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK2_KICK1=(0x0000900C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK3_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK3_KICK0=(0x0000D008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK3_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK3_KICK1=(0x0000D00C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK4_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK4_KICK0=(0x00011008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK4_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK4_KICK1=(0x0001100C)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK7_KICK0
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK7_KICK0=(0x0001D008)
LOCAL &__CSL_MAIN_CTRL_MMR_CFG0_LOCK7_KICK1
&__CSL_MAIN_CTRL_MMR_CFG0_LOCK7_KICK1=(0x0001D00C)
// -- MCU Control MMR Registers
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_MAC_ID0
&__CSL_MCU_CTRL_MMR_CFG0_MAC_ID0=(0x00000200)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_MAC_ID1
&__CSL_MCU_CTRL_MMR_CFG0_MAC_ID1=(0x00000204)
LOCAL &__CSL_MCU_SEC_MMR0_CFG0_BASE
&__CSL_MCU_SEC_MMR0_CFG0_BASE=(0x45a50000)
LOCAL &__CSL_MCU_SEC_MMR0_CFG0_SIZE
&__CSL_MCU_SEC_MMR0_CFG0_SIZE=(0x400)
LOCAL &__CSL_MCU_SEC_MMR0_CFG2_BASE
&__CSL_MCU_SEC_MMR0_CFG2_BASE=(0x45950000)
LOCAL &__CSL_MCU_SEC_MMR0_CFG2_SIZE
&__CSL_MCU_SEC_MMR0_CFG2_SIZE=(0x400)
LOCAL &__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE
&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE=(0x45a40000)
LOCAL &__CSL_MAIN_SEC_MMR0_BOOT_CTRL_SIZE
&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_SIZE=(0x4000)
// -- MCU Control MMR Lock Registers
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK0_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK0_KICK0=(0x00001008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK0_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK0_KICK1=(0x0000100C)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK1_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK1_KICK0=(0x00005008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK1_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK1_KICK1=(0x0000500C)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK2_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK2_KICK0=(0x00009008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK2_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK2_KICK1=(0x0000900C)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK3_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK3_KICK0=(0x0000D008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK3_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK3_KICK1=(0x0000D00C)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK4_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK4_KICK0=(0x00011008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK4_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK4_KICK1=(0x0001100C)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK6_KICK0
&__CSL_MCU_CTRL_MMR_CFG0_LOCK6_KICK0=(0x00019008)
LOCAL &__CSL_MCU_CTRL_MMR_CFG0_LOCK6_KICK1
&__CSL_MCU_CTRL_MMR_CFG0_LOCK6_KICK1=(0x0001900C)
// -- WKUP Control MMR Registers
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_JTAGID
&__CSL_WKUP_CTRL_MMR_CFG0_JTAGID=(0x00000014)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_JTAG_USER_ID
&__CSL_WKUP_CTRL_MMR_CFG0_JTAG_USER_ID=(0x00000018)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID0
&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID0=(0x00000020)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID1
&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID1=(0x00000024)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID2
&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID2=(0x00000028)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID3
&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID3=(0x0000002C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_DEVSTAT
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_DEVSTAT=(0x00000030)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_BOOTCFG
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_BOOTCFG=(0x00000034)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_POST_SEL_STAT
&__CSL_WKUP_CTRL_MMR_CFG0_POST_SEL_STAT=(0x00000038)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_POST_OPT
&__CSL_WKUP_CTRL_MMR_CFG0_POST_OPT=(0x0000003C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_BOOT_PROGRESS
&__CSL_WKUP_CTRL_MMR_CFG0_BOOT_PROGRESS=(0x00000044)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_RESET_SRC_STAT
&__CSL_WKUP_CTRL_MMR_CFG0_RESET_SRC_STAT=(0x00000050)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE0
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE0=(0x00000060)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE1
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE1=(0x00000064)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE2
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE2=(0x00000068)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE3
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE3=(0x0000006C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE4
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE4=(0x00000070)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE5
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE5=(0x00000074)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE6
&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE6=(0x00000078)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE0
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE0=(0x00000300)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE1
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE1=(0x00000304)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE2
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE2=(0x00000308)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE3
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE3=(0x0000030C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN1_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN1_CRC_FUSE=(0x0000C304)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN2_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN2_CRC_FUSE=(0x0000C308)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN3_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN3_CRC_FUSE=(0x0000C30C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN4_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN4_CRC_FUSE=(0x0000C310)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN6_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN6_CRC_FUSE=(0x0000C318)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN7_CRC_FUSE
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN7_CRC_FUSE=(0x0000C31C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV0
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV0=(0x00018150)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV1
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV1=(0x00018154)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV2
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV2=(0x00018158)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV3
&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV3=(0x0001815C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_RC12M_OSC_TRIM
&__CSL_WKUP_CTRL_MMR_CFG0_RC12M_OSC_TRIM=(0x00008024)
// -- Lock registers
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK0_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK0_KICK0=(0x00001008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK0_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK0_KICK1=(0x0000100C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK1_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK1_KICK0=(0x00005008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK1_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK1_KICK1=(0x0000500C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK0=(0x00009008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK2_KICK1=(0x0000900C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK3_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK3_KICK0=(0x0000D008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK3_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK3_KICK1=(0x0000D00C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK4_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK4_KICK0=(0x00011008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK4_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK4_KICK1=(0x0001100C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK6_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK6_KICK0=(0x00019008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK6_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK6_KICK1=(0x0001900C)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK7_KICK0
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK7_KICK0=(0x0001D008)
LOCAL &__CSL_WKUP_CTRL_MMR_CFG0_LOCK7_KICK1
&__CSL_WKUP_CTRL_MMR_CFG0_LOCK7_KICK1=(0x0001D00C)
// -- MMR unlock keys
LOCAL &__KICK0_UNLOCK_VAL
&__KICK0_UNLOCK_VAL=(0x68EF3490)
LOCAL &__KICK1_UNLOCK_VAL
&__KICK1_UNLOCK_VAL=(0xD172BC5A)
LOCAL &__KICK_LOCK_VAL
&__KICK_LOCK_VAL=(0x00000000)
// -- PSC Register Addresses to figure out which core we're running from
LOCAL &__WAKEUP_PSC_BASE
&__WAKEUP_PSC_BASE=(0x42000000)
LOCAL &__MAIN_PSC_BASE
&__MAIN_PSC_BASE=(0x00400000)
LOCAL &__PSC_PID
&__PSC_PID=(0x44827A00)
LOCAL &__M3_SOC_OFFSET
&__M3_SOC_OFFSET=(0x60000000)
LOCAL &__M3_RAT_CTRL
&__M3_RAT_CTRL=(0x44200020)

GLOBAL &path_J7AEP_eFuse_cmm
&path_J7AEP_eFuse_cmm=OS.PPF()
IF "&function"!=""
(
	GOSUB &function &args
)
ELSE
(
	GOSUB __GeL_MeNu_CrEaTe
)
ENDDO
// --  Function: J7AEP_getJTAGID() 
// -- *
// --  * \brief   Obtain the JTAG ID by reading the JTAG ID MMR holding the efuse
// --  *          value from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getJTAGID:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \JTAG_ID
	Var.NEWLOCAL unsigned int \JTAG_USER_ID
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- JTAG ID
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_JTAGID)+Var.Value(\address_offset))
	ENTRY &__V0
	Var.Assign \JTAG_ID=&__V0
	PRINT "** J7AEP JTAG Device ID Register **"
	PRINT ""
	PRINT ""
	AREA.Select
	PRINT "PG Variant   = " %HEX Var.VALUE(((\JTAG_ID&0xF0000000)>>0x1C)) ""
	PRINT ""
	AREA.Select
	PRINT "Part Number  = " %HEX Var.VALUE(((\JTAG_ID&0x0FFFF000)>>0xC)) ""
	PRINT ""
	AREA.Select
	PRINT "Manufacturer = " %HEX Var.VALUE(((\JTAG_ID&0x00000FFE)>>0x1)) ""
	PRINT ""
	AREA.Select
	PRINT "LSB = " %HEX Var.VALUE((\JTAG_ID&0x1)) ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_JTAG_USER_ID)+Var.Value(\address_offset))
	ENTRY &__V1
	Var.Assign \JTAG_USER_ID=&__V1
	AREA.Select
	PRINT " J7AEP JTAG User Code ID Register = " %HEX Var.VALUE(\JTAG_USER_ID) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getDIEID() 
// -- *
// --  * \brief   Obtain the DIE IDs by reading the 4 ID MMRs holding the efuse value
// --  *          from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getDIEID:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \DIE_ID0
	Var.NEWLOCAL unsigned int \DIE_ID1
	Var.NEWLOCAL unsigned int \DIE_ID2
	Var.NEWLOCAL unsigned int \DIE_ID3
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- DIE ID 0
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID0)+Var.Value(\address_offset))
	ENTRY &__V2
	Var.Assign \DIE_ID0=&__V2
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID1)+Var.Value(\address_offset))
	ENTRY &__V3
	Var.Assign \DIE_ID1=&__V3
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID2)+Var.Value(\address_offset))
	ENTRY &__V4
	Var.Assign \DIE_ID2=&__V4
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DIE_ID3)+Var.Value(\address_offset))
	ENTRY &__V5
	Var.Assign \DIE_ID3=&__V5
	PRINT "** J7AEP DIEID Registers (DIEID) **"
	PRINT ""
	PRINT ""
	AREA.Select
	PRINT "DIEID0 ---> " %HEX Var.VALUE(\DIE_ID0) ""
	PRINT ""
	AREA.Select
	PRINT "DIEID1 ---> " %HEX Var.VALUE(\DIE_ID1) ""
	PRINT ""
	AREA.Select
	PRINT "DIEID2 ---> " %HEX Var.VALUE(\DIE_ID2) ""
	PRINT ""
	AREA.Select
	PRINT "DIEID3 ---> " %HEX Var.VALUE(\DIE_ID3) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getMACID() 
// -- *
// --  * \brief   Obtain the MAC ID by reading the 2 ID MMRs holding the efuse value
// --  *          from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getMACID:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \MAC_ID0
	Var.NEWLOCAL unsigned int \MAC_ID1
	Var.NEWLOCAL unsigned int \MAC_ID
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- The MCU Control MMRs also use the address offset of 0x2000_0000.
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+&__CSL_MCU_CTRL_MMR_CFG0_MAC_ID0)+Var.Value(\address_offset))
	ENTRY &__V6
	Var.Assign \MAC_ID0=&__V6
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+&__CSL_MCU_CTRL_MMR_CFG0_MAC_ID1)+Var.Value(\address_offset))
	ENTRY &__V7
	Var.Assign \MAC_ID1=&__V7
	PRINT "** J7AEP MAC ID: **"
	PRINT ""
	PRINT ""
	AREA.Select
	PRINT "#: " %HEX Var.VALUE(\MAC_ID1) " _ " %HEX Var.VALUE(\MAC_ID0) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getBootROMConfiguration()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the bootROM configuration by reading the 4 ID MMRs holding the 
// --  * information from PORz (cold reset). 
// -- TODO: CHECK TO MAKE SURE THIS IS GOOD. Boot ROM configuration registers have changed.
// -- TODO: split the POST eFuse register reading into a separate function.
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

J7AEP_getBootRomConfiguration:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \WKUP_Devstat
	Var.NEWLOCAL unsigned int \WKUP_BootCfg
	Var.NEWLOCAL unsigned int \WKUP_BootProgress
	Var.NEWLOCAL unsigned int \Main_Devstat
	Var.NEWLOCAL unsigned int \Main_BootCfg
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- WKUP CTRL MMRs use the offset of 0x2000_0000.
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_DEVSTAT)+Var.Value(\address_offset))
	ENTRY &__V8
	Var.Assign \WKUP_Devstat=&__V8
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_BOOTCFG)+Var.Value(\address_offset))
	ENTRY &__V9
	Var.Assign \WKUP_BootCfg=&__V9
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_BOOT_PROGRESS)+Var.Value(\address_offset))
	ENTRY &__V10
	Var.Assign \WKUP_BootProgress=&__V10
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	// -- Main CTRL MMRs use the offset of 0x8000_0000.
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_DEVSTAT)+Var.Value(\address_offset))
	ENTRY &__V11
	Var.Assign \Main_Devstat=&__V11
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_BOOTCFG)+Var.Value(\address_offset))
	ENTRY &__V12
	Var.Assign \Main_BootCfg=&__V12
	PRINT "** J7AEP BootROM configuration: **"
	PRINT ""
	PRINT ""
	PRINT "Wakeup DEVSTAT for MCU bootstrap configuration is as follows: "
	AREA.Select
	PRINT "" %HEX Var.VALUE(\WKUP_Devstat) ""
	PRINT ""
	AREA.Select
	PRINT "POST Mode: " %DECIMAL Var.VALUE(((\WKUP_Devstat&0x300)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "MCU Primary and Secondary Boot Mode: " %DECIMAL Var.VALUE(((\WKUP_Devstat&0xF8)>>0x3)) ""
	PRINT ""
	AREA.Select
	PRINT "HFOSC0 Frequency Selection: " %HEX Var.VALUE((\WKUP_Devstat&0x7)) ""
	PRINT ""
	PRINT "MCU Boot Configuration from WKUP_BOOTCFG is as follows "
	AREA.Select
	PRINT "" %HEX Var.VALUE(\WKUP_BootCfg) ""
	PRINT ""
	PRINT "ROM Boot Progress MMR is as follows: "
	PRINT ""
	AREA.Select
	PRINT "Progress: " %HEX Var.VALUE(\WKUP_BootProgress) ""
	PRINT ""
	PRINT "Main SoC Bootstrap configuration from MAIN_DEVSTAT is as follows: "
	PRINT ""
	AREA.Select
	PRINT "Primary Boot Media: " %HEX Var.VALUE(\Main_Devstat) ""
	PRINT ""
	PRINT "Main SoC Boostrap Selection from MAIN_BOOTCFG is as follows: "
	PRINT ""
	AREA.Select
	PRINT "Primary Boot Media: " %HEX Var.VALUE(\Main_BootCfg) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getA72_En_Status() 
// -- *
// --  * \brief   Obtain the A72 CPU configuration by reading the MMRs holding the 
// --  *          efuse values from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getA72_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Device_Feature_0
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	PRINT "** J7AEP A72 CPU Status: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE0)+Var.Value(\address_offset))
	ENTRY &__V13
	Var.Assign \Device_Feature_0=&__V13
	Var.IF (((\Device_Feature_0)&0x3)==0x1)
	(
		// -- Only Core 0 is enabled, all fuses blown
		PRINT "ARM A72 Core 0 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "ARM A72 Cores 0 and 1 enabled."
		PRINT ""
	)
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getGPU_En_Status() 
// -- *
// --  * \brief   Obtain the GPU hardware configuration by reading the MMR holding the 
// --  * efuse value from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getGPU_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Device_Feature_1
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	PRINT "** J7AEP GPU Status: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE1)+Var.Value(\address_offset))
	ENTRY &__V14
	Var.Assign \Device_Feature_1=&__V14
	Var.IF ((((\Device_Feature_1)&0x1000)>>0xC)!=0)
	(
		// -- GPU is enabled if this fuse isn't blown
		PRINT "The GPU is enabled on this device."
		PRINT ""
	)
	ELSE
	(
		PRINT "The GPU is diabled on this device."
		PRINT ""
	)
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getDSP_En_Status() 
// -- *
// --  * \brief   Read the eFuses for the DSP Cores.
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getDSP_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Device_Feature_1
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	PRINT "** J7AEP DSP Status: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE1)+Var.Value(\address_offset))
	ENTRY &__V15
	Var.Assign \Device_Feature_1=&__V15
	Var.IF ((((\Device_Feature_1)&0x20000)>>0x11)!=0)
	(
		PRINT "C71 DSP #1 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "C71 DSP #1 Disabled."
		PRINT ""
	)
	Var.IF ((((\Device_Feature_1)&0x10000)>>0x10)!=0)
	(
		PRINT "C71 DSP #0 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "C71 DSP #0 Disabled."
		PRINT ""
	)
	// -- Check the C66 DSPs
	// -- 	if((Device_Feature_1 & 0x200) >> 9){
	// -- 		GEL_TextOut("C66 DSP #1 enabled.\n");
	// -- 	}else{
	// -- 		GEL_TextOut("C66 DSP #1 Disabled.\n");
	// -- 	}
	// -- 	if((Device_Feature_1 & 0x100) >> 8){
	// -- 		GEL_TextOut("C66 DSP #1 enabled.\n");
	// -- 	}else{
	// -- 		GEL_TextOut("C66 DSP #1 Disabled.\n");
	// -- 	}
	RETURN
)
// --  Function: J7AEP_getR5F_En_Status() 
// -- *
// --  * \brief   Read the eFuses for the Main R5F cores.
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getR5F_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Device_Feature_1
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	PRINT "** J7AEP Safety MCU Status: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE1)+Var.Value(\address_offset))
	ENTRY &__V16
	Var.Assign \Device_Feature_1=&__V16
	Var.IF (((\Device_Feature_1)&0x1)!=0)
	(
		PRINT "Main Cluster 0 R5F #0 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 0 R5F #0 Disabled."
		PRINT ""
	)
	Var.IF ((((\Device_Feature_1)&0x2)>>0x1)!=0)
	(
		PRINT "Main Cluster 0 R5F #1 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 0 R5F #1 Disabled."
		PRINT ""
	)
	Var.IF ((((\Device_Feature_1)&0x4)>>0x2)!=0)
	(
		PRINT "Main Cluster 1 R5F #0 enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 1 R5F #0 Disabled."
		PRINT ""
	)
	Var.IF ((((\Device_Feature_1)&0x8)>>0x3)!=0)
	(
		PRINT "Main Cluster 1 R5F #1 enabled."
		PRINT ""
		PRINT "All Main R5F cores enabled."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 1 R5F #1 Disabled."
		PRINT ""
	)
	RETURN
)
// --  Function: J7AEP_getHardwareFeature_En_Status() 
// -- *
// --  * \brief   Obtain the periperal hardware configuration by reading the MMRs 
// --  *          holding the efuse values from PORz (cold reset).
// --  *
// --  * \param   unsigned int address_offset
// --  *
// --  * \return  none

J7AEP_getHardwareFeature_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_2
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_3
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_4
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_5
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_6
	Var.NEWLOCAL unsigned int \WKUP_Spare_Fuse0
	Var.NEWLOCAL unsigned int \WKUP_Spare_Fuse1
	Var.NEWLOCAL unsigned int \WKUP_Spare_Fuse2
	Var.NEWLOCAL unsigned int \WKUP_Spare_Fuse3
	Var.NEWLOCAL unsigned int \WKUP_Chain1_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_Chain2_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_Chain3_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_Chain4_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_Chain6_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_Chain7_CRC_Efuse
	Var.NEWLOCAL unsigned int \WKUP_POK_RSV0
	Var.NEWLOCAL unsigned int \WKUP_POK_RSV1
	Var.NEWLOCAL unsigned int \WKUP_POK_RSV2
	Var.NEWLOCAL unsigned int \WKUP_POK_RSV3
	Var.NEWLOCAL unsigned int \Main_Device_Feature_0
	Var.NEWLOCAL unsigned int \Main_Device_Feature_1
	Var.NEWLOCAL unsigned int \Main_Spare_Fuse0
	Var.NEWLOCAL unsigned int \Main_Spare_Fuse1
	Var.NEWLOCAL unsigned int \Main_Spare_Fuse2
	Var.NEWLOCAL unsigned int \Main_Spare_Fuse3
	Var.NEWLOCAL unsigned int \Main_Spare_Trim0
	Var.NEWLOCAL unsigned int \Main_Spare_Trim1
	Var.NEWLOCAL unsigned int \Main_Spare_Trim2
	Var.NEWLOCAL unsigned int \Main_Spare_Trim3
	Var.NEWLOCAL unsigned int \main_address_offset
	Var.Assign \main_address_offset=0x0
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode0
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode1
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode2
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode3
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode4
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode5
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode6
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode7
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode8
	Var.NEWLOCAL unsigned int \Main_AVS_Core_Margin_Mode9
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
		Var.Assign \main_address_offset=0x80000000
	)
	// -- WKUP CTRL MMRs use the offset of 0x2000_0000.
	// -- Device Feature 2
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE2)+Var.Value(\address_offset))
	ENTRY &__V17
	Var.Assign \WKUP_Device_Feature_2=&__V17
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE3)+Var.Value(\address_offset))
	ENTRY &__V18
	Var.Assign \WKUP_Device_Feature_3=&__V18
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE4)+Var.Value(\address_offset))
	ENTRY &__V19
	Var.Assign \WKUP_Device_Feature_4=&__V19
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE5)+Var.Value(\address_offset))
	ENTRY &__V20
	Var.Assign \WKUP_Device_Feature_5=&__V20
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE6)+Var.Value(\address_offset))
	ENTRY &__V21
	Var.Assign \WKUP_Device_Feature_6=&__V21
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE0)+Var.Value(\address_offset))
	ENTRY &__V22
	Var.Assign \WKUP_Spare_Fuse0=&__V22
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE1)+Var.Value(\address_offset))
	ENTRY &__V23
	Var.Assign \WKUP_Spare_Fuse1=&__V23
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE2)+Var.Value(\address_offset))
	ENTRY &__V24
	Var.Assign \WKUP_Spare_Fuse2=&__V24
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_SPARE_FUSE3)+Var.Value(\address_offset))
	ENTRY &__V25
	Var.Assign \WKUP_Spare_Fuse3=&__V25
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV0)+Var.Value(\address_offset))
	ENTRY &__V26
	Var.Assign \WKUP_POK_RSV0=&__V26
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV1)+Var.Value(\address_offset))
	ENTRY &__V27
	Var.Assign \WKUP_POK_RSV1=&__V27
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV2)+Var.Value(\address_offset))
	ENTRY &__V28
	Var.Assign \WKUP_POK_RSV2=&__V28
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_POK_RSV3)+Var.Value(\address_offset))
	ENTRY &__V29
	Var.Assign \WKUP_POK_RSV3=&__V29
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN1_CRC_FUSE)+Var.Value(\address_offset))
	ENTRY &__V30
	Var.Assign \WKUP_Chain1_CRC_Efuse=&__V30
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_WKUP_CHAIN2_CRC_FUSE)+Var.Value(\address_offset))
	ENTRY &__V31
	Var.Assign \WKUP_Chain2_CRC_Efuse=&__V31
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_0)+Var.Value(\main_address_offset))
	ENTRY &__V32
	Var.Assign \Main_Device_Feature_0=&__V32
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_1)+Var.Value(\main_address_offset))
	ENTRY &__V33
	Var.Assign \Main_Device_Feature_1=&__V33
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE0)+Var.Value(\main_address_offset))
	ENTRY &__V34
	Var.Assign \Main_Spare_Fuse0=&__V34
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE1)+Var.Value(\main_address_offset))
	ENTRY &__V35
	Var.Assign \Main_Spare_Fuse1=&__V35
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE2)+Var.Value(\main_address_offset))
	ENTRY &__V36
	Var.Assign \Main_Spare_Fuse2=&__V36
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_FUSE3)+Var.Value(\main_address_offset))
	ENTRY &__V37
	Var.Assign \Main_Spare_Fuse3=&__V37
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM0)+Var.Value(\main_address_offset))
	ENTRY &__V38
	Var.Assign \Main_Spare_Trim0=&__V38
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM1)+Var.Value(\main_address_offset))
	ENTRY &__V39
	Var.Assign \Main_Spare_Trim1=&__V39
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM2)+Var.Value(\main_address_offset))
	ENTRY &__V40
	Var.Assign \Main_Spare_Trim2=&__V40
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_SPARE_TRIM3)+Var.Value(\main_address_offset))
	ENTRY &__V41
	Var.Assign \Main_Spare_Trim3=&__V41
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE0)+Var.Value(\main_address_offset))
	ENTRY &__V42
	Var.Assign \Main_AVS_Core_Margin_Mode0=&__V42
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE1)+Var.Value(\main_address_offset))
	ENTRY &__V43
	Var.Assign \Main_AVS_Core_Margin_Mode1=&__V43
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE2)+Var.Value(\main_address_offset))
	ENTRY &__V44
	Var.Assign \Main_AVS_Core_Margin_Mode2=&__V44
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE3)+Var.Value(\main_address_offset))
	ENTRY &__V45
	Var.Assign \Main_AVS_Core_Margin_Mode3=&__V45
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE4)+Var.Value(\main_address_offset))
	ENTRY &__V46
	Var.Assign \Main_AVS_Core_Margin_Mode4=&__V46
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE5)+Var.Value(\main_address_offset))
	ENTRY &__V47
	Var.Assign \Main_AVS_Core_Margin_Mode5=&__V47
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE6)+Var.Value(\main_address_offset))
	ENTRY &__V48
	Var.Assign \Main_AVS_Core_Margin_Mode6=&__V48
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE7)+Var.Value(\main_address_offset))
	ENTRY &__V49
	Var.Assign \Main_AVS_Core_Margin_Mode7=&__V49
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE8)+Var.Value(\main_address_offset))
	ENTRY &__V50
	Var.Assign \Main_AVS_Core_Margin_Mode8=&__V50
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_AVS_CORE_MRGN_MODE9)+Var.Value(\main_address_offset))
	ENTRY &__V51
	Var.Assign \Main_AVS_Core_Margin_Mode9=&__V51
	PRINT "** J7AEP Device Features: **"
	PRINT ""
	PRINT ""
	AREA.Select
	PRINT " Main Device Feature 0 = " %HEX Var.VALUE(\Main_Device_Feature_0) ""
	PRINT ""
	AREA.Select
	PRINT " Main Device Feature 1 = " %HEX Var.VALUE(\Main_Device_Feature_1) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 0 (main_gp_ro0[31:0]) = " %HEX Var.VALUE(\Main_Spare_Fuse0) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 1 (main_gp_ro1[31:0]) = " %HEX Var.VALUE(\Main_Spare_Fuse1) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 2 (main_gp_ro2[31:0]) = " %HEX Var.VALUE(\Main_Spare_Fuse2) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 3 (main_gp_ro3[31:0]) = " %HEX Var.VALUE(\Main_Spare_Fuse3) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare Trim0 (main_gp_rw0[31:0]) = " %HEX Var.VALUE(\Main_Spare_Trim0) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare Trim1 (main_gp_rw1[31:0]) = " %HEX Var.VALUE(\Main_Spare_Trim1) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare Trim2 (main_gp_rw2[31:0]) = " %HEX Var.VALUE(\Main_Spare_Trim2) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare Trim3 (main_gp_rw3[31:0]) = " %HEX Var.VALUE(\Main_Spare_Trim3) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup POK Reserve [31:0] = " %HEX Var.VALUE(\WKUP_POK_RSV0) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup POK Reserve [63:32] = " %HEX Var.VALUE(\WKUP_POK_RSV1) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup POK Reserve [95:64] = " %HEX Var.VALUE(\WKUP_POK_RSV2) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup POK Reserve [127:96] = " %HEX Var.VALUE(\WKUP_POK_RSV3) ""
	PRINT ""
	AREA.Select
	PRINT " hs2parf_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode0&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hs2parf_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode0&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hs2parf_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode0&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hs2parf_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode0&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hddp_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode1&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hddp_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode1&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hddp_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode1&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hddp_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode1&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " ehdsp_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode2&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " ehdsp_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode2&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " ehdsp_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode2&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " ehdsp_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode2&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hd2parf_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode3&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hd2parf_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode3&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hd2parf_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode3&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hd2parf_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode3&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " uhd2parf_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode4&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " uhd2parf_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode4&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " uhd2parf_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode4&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " uhd2parf_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode4&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " rom_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode5&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " rom_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode5&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " rom_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode5&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " rom_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode5&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hdsp_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode6&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hdsp_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode6&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hdsp_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode6&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hdsp_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode6&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hssp_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode7&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hssp_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode7&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hssp_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode7&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hssp_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode7&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hd1prf_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode8&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hd1prf_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode8&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hd1prf_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode8&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hd1prf_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode8&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " hs1prf_mem_margin_assist_dft_mem_margin = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode9&0xF)>>0x0)) ""
	PRINT ""
	AREA.Select
	PRINT " hs1prf_mem_margin_assist_dft_mem_ra = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode9&0x30)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT " hs1prf_mem_margin_assist_dft_mem_wa = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode9&0x1C0)>>0x6)) ""
	PRINT ""
	AREA.Select
	PRINT " hs1prf_mem_margin_assist_dft_wpulse = " %HEX Var.VALUE(((\Main_AVS_Core_Margin_Mode9&0xE00)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup Chain1 CRC Fuse = " %HEX Var.VALUE(\WKUP_Chain1_CRC_Efuse) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup Chain2 CRC Fuse = " %HEX Var.VALUE(\WKUP_Chain2_CRC_Efuse) ""
	PRINT ""
	AREA.Select
	PRINT " Wakeup Spare General Purpose Fuse 0 (gp0[31:0]) = " %HEX Var.VALUE(\WKUP_Spare_Fuse0) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 1 (gp1[31:0]) = " %HEX Var.VALUE(\WKUP_Spare_Fuse1) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 2 (gp2[31:0]) = " %HEX Var.VALUE(\WKUP_Spare_Fuse2) ""
	PRINT ""
	AREA.Select
	PRINT " Main Spare General Purpose Fuse 3 (gp3[31:0]) = " %HEX Var.VALUE(\WKUP_Spare_Fuse3) ""
	PRINT ""
	Var.IF ((((\Main_Device_Feature_1)&0x8000)>>0xF)!=0)
	(
		// -- If the bit is set, that means GPU Adaptive Scalable Texture Compression is supported.
		PRINT "GPU Adaptive Scalable Texture Compression is enabled (gpu_astc_en) "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "GPU Adaptive Scalable Texture Compression is disabled (gpu_astc_en) "
		PRINT ""
	)
	// -- MAIN MCAN FD
	Var.IF ((((\Main_Device_Feature_1)&0x10000)>>0x10)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN0 FD is 0 AKA burned.
		PRINT "MAIN MCAN FD/real-time functionality enabled. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MAIN MCAN FD/real-time functionality disabled. "
		PRINT ""
	)
	// -- dec_h264_en
	Var.IF ((((\Main_Device_Feature_1)&0x1)>>0x0)!=0)
	(
		// -- If the bit is set, that means the H.264 Video decode is enabled when set.
		PRINT "H.264 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "H.264 Video decode is disabled "
		PRINT ""
	)
	// -- dec_hevc_en
	Var.IF ((((\Main_Device_Feature_1)&0x2)>>0x1)!=0)
	(
		// -- If the bit is set, that means the HEVC (H.265) Video decode is enabled when set
		PRINT "HEVC (H.265) Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "HEVC (H.265) Video decode is disabled "
		PRINT ""
	)
	// -- dec_vc1_en
	Var.IF ((((\Main_Device_Feature_1)&0x4)>>0x2)!=0)
	(
		// -- If the bit is set, that means the VC-1 (SMPTE 421M) Video decode is enabled when set
		PRINT "VC-1 (SMPTE 421M) Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VC-1 (SMPTE 421M) Video decode is disabled "
		PRINT ""
	)
	// -- dec_wmv9_en
	Var.IF ((((\Main_Device_Feature_1)&0x8)>>0x3)!=0)
	(
		// -- If the bit is set, that means the WMV9 Video decode is enabled when set
		PRINT "WMV9 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "WMV9 Video decode is disabled "
		PRINT ""
	)
	// -- dec_mpeg1_en
	Var.IF ((((\Main_Device_Feature_1)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the MPEG1 Video decode is enabled
		PRINT "MPEG1 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MPEG1 Video decode is disabled "
		PRINT ""
	)
	// -- dec_mpeg2_en
	Var.IF ((((\Main_Device_Feature_1)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the MPEG2 Video decode is enabled
		PRINT "MPEG2 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MPEG2 Video decode is disabled "
		PRINT ""
	)
	// -- dec_mpeg4_en
	Var.IF ((((\Main_Device_Feature_1)&0x40)>>0x6)!=0)
	(
		// -- If the bit is set, that means the MPEG4 Video decode is enabled
		PRINT "MPEG4 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MPEG4 Video decode is disabled "
		PRINT ""
	)
	// -- dec_avs_en
	Var.IF ((((\Main_Device_Feature_1)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the AVS Video decode is enabled
		PRINT "AVS Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "AVS Video decode is disabled "
		PRINT ""
	)
	// -- dec_soren_en
	Var.IF ((((\Main_Device_Feature_1)&0x100)>>0x8)!=0)
	(
		// -- If the bit is set, that means the Sorenson Video decode is enabled
		PRINT "Sorenson Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Sorenson Video decode is disabled "
		PRINT ""
	)
	// -- dec_rv_en
	Var.IF ((((\Main_Device_Feature_1)&0x200)>>0x9)!=0)
	(
		// -- If the bit is set, that means the RealVideo Video decode is enabled
		PRINT "RealVideo Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "RealVideo Video decode is disabled "
		PRINT ""
	)
	// -- dec_vp6_en
	Var.IF ((((\Main_Device_Feature_1)&0x400)>>0xA)!=0)
	(
		// -- If the bit is set, that means the VP6 Video decode is enabled
		PRINT "VP6 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VP6 Video decode is disabled "
		PRINT ""
	)
	// -- dec_vp8_en
	Var.IF ((((\Main_Device_Feature_1)&0x800)>>0xB)!=0)
	(
		// -- If the bit is set, that means the VP8 Video decode is enabled
		PRINT "VP8 Video decode is enabled "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VP8 Video decode is disabled "
		PRINT ""
	)
	// -- WKUP MCAN FD
	Var.IF (((\WKUP_Device_Feature_2)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN0 FD is 0 AKA burned.
		PRINT "WKUP MCAN FD/real-time functionality enabled. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "WKUP MCAN FD/real-time functionality disabled. "
		PRINT ""
	)
	// -- MCAN #0
	Var.IF ((((\WKUP_Device_Feature_2)&0x2)>>0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN0 is 0 AKA not burned.
		PRINT "MCAN0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN #1
	Var.IF ((((\WKUP_Device_Feature_2)&0x8)>>0x3)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN1 is 0 AKA not burned.
		PRINT "MCAN1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- OSPI #0
	Var.IF ((((\WKUP_Device_Feature_2)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN1 is 0 AKA not burned.
		PRINT "OSPI0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "OSPI0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- OSPI #1
	Var.IF ((((\WKUP_Device_Feature_2)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN1 is 0 AKA not burned.
		PRINT "OSPI1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "OSPI1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- Hyperbus (HBMC)
	Var.IF ((((\WKUP_Device_Feature_2)&0x40)>>0x6)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN1 is 0 AKA not burned.
		PRINT "Hyperbus (HBMC) peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Hyperbus (HBMC) peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- AES Encryption
	Var.IF ((((\WKUP_Device_Feature_2)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the eFuse for AES encryption is 1, burned.
		PRINT "AES authentication enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse isn't blown (eFuse reads 0).
		PRINT "AES authentication disabled via eFuse. "
		PRINT ""
	)
	PRINT "Main peripherals: "
	PRINT ""
	Var.IF (((\WKUP_Device_Feature_3)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for USB0 is 0 AKA not burned.
		PRINT "USB0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "USB0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- USB1
	Var.IF ((((\WKUP_Device_Feature_3)&0x2)>>0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for USB1 is 0 AKA not burned.
		PRINT "USB1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "USB1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- USB2 eFuse is reserved for customers.
	// -- PCIe0
	Var.IF ((((\WKUP_Device_Feature_3)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the eFuse for PCIe0 is 0 AKA not burned.
		PRINT "PCIe0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "PCIe0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- PCIe1
	Var.IF ((((\WKUP_Device_Feature_3)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the eFuse for PCIe1 is 0 AKA not burned.
		PRINT "PCIe1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "PCIe1 peripheral disabled via eFuse. "
		PRINT ""
	)
	PRINT "Checking Sierra SERDES: "
	PRINT ""
	Var.IF ((((\WKUP_Device_Feature_3)&0x100)>>0x8)!=0)
	(
		// -- If the bit is set, that means the eFuse for SERDES0 is 0 AKA not burned.
		PRINT "SERDES0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "SERDES0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- SERDES1
	Var.IF ((((\WKUP_Device_Feature_3)&0x200)>>0x9)!=0)
	(
		// -- If the bit is set, that means the eFuse for SERDES1 is 0 AKA not burned.
		PRINT "SERDES1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "SERDES1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- SERDES2
	Var.IF ((((\WKUP_Device_Feature_3)&0x400)>>0xA)!=0)
	(
		// -- If the bit is set, that means the eFuse for SERDES0 is 0 AKA not burned.
		PRINT "SERDES2 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "SERDES2 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- SERDES3
	Var.IF ((((\WKUP_Device_Feature_3)&0x800)>>0xB)!=0)
	(
		// -- If the bit is set, that means the eFuse for SERDES0 is 0 AKA not burned.
		PRINT "SERDES3 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "SERDES3 peripheral disabled via eFuse. "
		PRINT ""
	)
	PRINT "Checking Torrent SERDES: "
	PRINT ""
	Var.IF ((((\WKUP_Device_Feature_3)&0x1000)>>0xC)!=0)
	(
		// -- If the bit is set, that means the eFuse for SERDES0 is 0 AKA not burned.
		PRINT "Torrent SERDES 0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Torrent SERDES 0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- Torrent SERDES 1 eFuse is reserved for the customers.
	// -- ICSSG0
	Var.IF ((((\WKUP_Device_Feature_3)&0x10000)>>0x10)!=0)
	(
		// -- If the bit is set, that means the eFuse for ICSSG0 is 0 AKA not burned.
		PRINT "ICSSG0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "ICSSG0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- ICSSG1
	Var.IF ((((\WKUP_Device_Feature_3)&0x20000)>>0x11)!=0)
	(
		// -- If the bit is set, that means the eFuse for ICSSG1 is 0 AKA not burned.
		PRINT "ICSSG1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "ICSSG1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- MMC 8 bit
	Var.IF ((((\WKUP_Device_Feature_3)&0x100000)>>0x14)!=0)
	(
		// -- If the bit is set, that means the eFuse for MMC 8 bit is 0 AKA not burned.
		PRINT "eMMC/SD 8-bit peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "eMMC/SD 8-bit peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- MMC 4 bit 0
	Var.IF ((((\WKUP_Device_Feature_3)&0x200000)>>0x15)!=0)
	(
		// -- If the bit is set, that means the eFuse for MMC 4 bit 0 is 0 AKA not burned.
		PRINT "eMMC/SD 0 4-bit peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "eMMC/SD 0 4-bit peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- MMC 4 bit 1
	Var.IF ((((\WKUP_Device_Feature_3)&0x400000)>>0x16)!=0)
	(
		// -- If the bit is set, that means the eFuse for MMC 4 bit 1 is 0 AKA not burned.
		PRINT "eMMC/SD 1 4-bit peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "eMMC/SD 1 4-bit peripheral disabled via eFuse. "
		PRINT ""
	)
	PRINT "Checking DDR hardware: "
	PRINT ""
	Var.IF ((((\WKUP_Device_Feature_3)&0x10000000)>>0x1C)!=0)
	(
		// -- If the bit is set, that means the eFuse for EMIF 0 is 0 AKA not burned.
		PRINT "eMMC/SD 8-bit peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "eMMC/SD 8-bit peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- EMIF 1 eFuse is reserved for customers.
	// -- DSS
	Var.IF (((\WKUP_Device_Feature_4)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for DSS is 0 AKA not burned.
		PRINT "DSS peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "DSS peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- DSI
	Var.IF ((((\WKUP_Device_Feature_4)&0x4)>>0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for DSI is 0 AKA not burned.
		PRINT "DSI peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "DSI peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- CSIRX_0
	Var.IF ((((\WKUP_Device_Feature_4)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the eFuse for CSIRX_0 is 0 AKA not burned.
		PRINT "CSIRX_0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "CSIRX_0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- CSIRX_1
	Var.IF ((((\WKUP_Device_Feature_4)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the eFuse for CSIRX_0 is 0 AKA not burned.
		PRINT "CSIRX_1 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "CSIRX_1 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- CSIRX_2 eFuse is reserved for customers.
	// -- CSITX_0
	Var.IF ((((\WKUP_Device_Feature_4)&0x100)>>0x8)!=0)
	(
		// -- If the bit is set, that means the eFuse for CSITX_0 is 0 AKA not burned.
		PRINT "CSITX_0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "CSITX_0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- eDP_0
	Var.IF ((((\WKUP_Device_Feature_4)&0x1000)>>0xC)!=0)
	(
		// -- If the bit is set, that means the eFuse for eDP_0 is 0 AKA not burned.
		PRINT "eDP_0 peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "eDP_0 peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- eDP_1 eFuse is reserved for customers.
	// -- DMPAC
	Var.IF ((((\WKUP_Device_Feature_4)&0x10000)>>0x10)!=0)
	(
		// -- If the bit is set, that means the eFuse for DMPAC is 0 AKA not burned.
		PRINT "DMPAC peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "DMPAC peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- DMPAC SDE
	Var.IF ((((\WKUP_Device_Feature_4)&0x20000)>>0x11)!=0)
	(
		// -- If the bit is set, that means the eFuse for DMPAC is 0 AKA not burned.
		PRINT "DMPAC SDE enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "DMPAC SDE disabled via eFuse. "
		PRINT ""
	)
	// -- VPAC
	Var.IF ((((\WKUP_Device_Feature_4)&0x40000)>>0x12)!=0)
	(
		// -- If the bit is set, that means the eFuse for VPAC is 0 AKA not burned.
		PRINT "VPAC peripheral enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VPAC peripheral disabled via eFuse. "
		PRINT ""
	)
	// -- VPE
	Var.IF ((((\WKUP_Device_Feature_4)&0x80000)>>0x13)!=0)
	(
		// -- If the bit is set, that means the eFuse for VPE is 0 AKA not burned.
		PRINT "VPE enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VPE disabled via eFuse. "
		PRINT ""
	)
	// -- VPFE
	Var.IF ((((\WKUP_Device_Feature_4)&0x100000)>>0x14)!=0)
	(
		// -- If the bit is set, that means the eFuse for VPFE is 0 AKA not burned.
		PRINT "VPFE enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "VPFE disabled via eFuse. "
		PRINT ""
	)
	// -- //Encoder
	// -- 	if(((WKUP_Device_Feature_4 & 0x1000000) >> 24)){
	// -- 		//If the bit is set, that means the eFuse for Encoder is 0 AKA not burned.
	// -- 		GEL_TextOut("Encoder enabled via eFuse. \n");
	// -- 	}else{
	// -- 		//If the bit is not set, that means the eFuse is blown (eFuse is set).
	// -- 		GEL_TextOut("Encoder disabled via eFuse. \n");
	// -- 	}
	// -- 	//Decoder
	// -- 	if(((WKUP_Device_Feature_4 & 0x2000000) >> 25)){
	// -- 		//If the bit is set, that means the eFuse for Decoder is 0 AKA not burned.
	// -- 		GEL_TextOut("Decoder enabled via eFuse. \n");
	// -- 	}else{
	// -- 		//If the bit is not set, that means the eFuse is blown (eFuse is set).
	// -- 		GEL_TextOut("Decoder disabled via eFuse. \n");
	// -- 	}
	Var.IF ((((\WKUP_Device_Feature_4)&0x4000000)>>0x1A)!=0)
	(
		// -- If the bit is set, that means the eFuse for the Codec/VPU is 0 AKA not burned. 
		PRINT "VPU enabled via eFuse."
		PRINT ""
	)
	ELSE
	(
		PRINT "VPU enabled via eFuse."
		PRINT ""
	)
	PRINT "Checking MCAN Features: "
	PRINT ""
	Var.IF (((\WKUP_Device_Feature_5)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_0 is 0 AKA not burned.
		PRINT "MCAN_0 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_0 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_1
	Var.IF ((((\WKUP_Device_Feature_5)&0x2)>>0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_1 is 0 AKA not burned.
		PRINT "MCAN_1 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_1 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_2
	Var.IF ((((\WKUP_Device_Feature_5)&0x4)>>0x2)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_2 is 0 AKA not burned.
		PRINT "MCAN_2 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_2 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_3
	Var.IF ((((\WKUP_Device_Feature_5)&0x8)>>0x3)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_3 is 0 AKA not burned.
		PRINT "MCAN_3 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_3 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_4
	Var.IF ((((\WKUP_Device_Feature_5)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_4 is 0 AKA not burned.
		PRINT "MCAN_4 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_4 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_5
	Var.IF ((((\WKUP_Device_Feature_5)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_5 is 0 AKA not burned.
		PRINT "MCAN_5 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_5 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_6
	Var.IF ((((\WKUP_Device_Feature_5)&0x40)>>0x6)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_6 is 0 AKA not burned.
		PRINT "MCAN_6 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_6 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_7
	Var.IF ((((\WKUP_Device_Feature_5)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_7 is 0 AKA not burned.
		PRINT "MCAN_7 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_7 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_8
	Var.IF ((((\WKUP_Device_Feature_5)&0x100)>>0x8)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_8 is 0 AKA not burned.
		PRINT "MCAN_8 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_8 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_9
	Var.IF ((((\WKUP_Device_Feature_5)&0x200)>>0x9)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_9 is 0 AKA not burned.
		PRINT "MCAN_9 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_9 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_10
	Var.IF ((((\WKUP_Device_Feature_5)&0x400)>>0xA)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_10 is 0 AKA not burned.
		PRINT "MCAN_10 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_10 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_11
	Var.IF ((((\WKUP_Device_Feature_5)&0x800)>>0xA)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_11 is 0 AKA not burned.
		PRINT "MCAN_11 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_11 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_12
	Var.IF ((((\WKUP_Device_Feature_5)&0x1000)>>0xC)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_12 is 0 AKA not burned.
		PRINT "MCAN_12 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_12 disabled via eFuse. "
		PRINT ""
	)
	// -- MCAN_13
	Var.IF ((((\WKUP_Device_Feature_5)&0x2000)>>0xD)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN_13 is 0 AKA not burned.
		PRINT "MCAN_13 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN_13 disabled via eFuse. "
		PRINT ""
	)
	// -- UFS_0
	Var.IF (((\WKUP_Device_Feature_6)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for UFS_0 is 0 AKA not burned.
		PRINT "UFS_0 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "UFS_0 disabled via eFuse. "
		PRINT ""
	)
	// -- UFS_1 eFuse reserved for customers.
	// -- CPSW_9G
	Var.IF ((((\WKUP_Device_Feature_6)&0x10)>>0x4)!=0)
	(
		// -- If the bit is set, that means the eFuse for CPSW_9G is 0 AKA not burned.
		PRINT "CPSW_9G enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "CPSW_9G disabled via eFuse. "
		PRINT ""
	)
	// -- SA2_UL
	Var.IF ((((\WKUP_Device_Feature_6)&0x20)>>0x5)!=0)
	(
		// -- If the bit is set, that means the eFuse for SA2_UL is 0 AKA not burned.
		PRINT "SA2_UL enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "SA2_UL disabled via eFuse. "
		PRINT ""
	)
	// -- MLB
	Var.IF ((((\WKUP_Device_Feature_6)&0x40)>>0x6)!=0)
	(
		// -- If the bit is set, that means the eFuse for MLB is 0 AKA not burned.
		PRINT "MLB enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MLB disabled via eFuse. "
		PRINT ""
	)
	// -- ATL
	Var.IF ((((\WKUP_Device_Feature_6)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the eFuse for ATL is 0 AKA not burned.
		PRINT "ATL enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "ATL disabled via eFuse. "
		PRINT ""
	)
	// -- Motor Peripherals
	Var.IF ((((\WKUP_Device_Feature_6)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the eFuse for MOTOR is 0 AKA not burned.
		PRINT "Motor Peripherals enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Motor Peripherals disabled via eFuse. "
		PRINT ""
	)
	// -- I3C
	Var.IF ((((\WKUP_Device_Feature_6)&0x80)>>0x7)!=0)
	(
		// -- If the bit is set, that means the eFuse for I3C is 0 AKA not burned.
		PRINT "I3C enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "I3C disabled via eFuse. "
		PRINT ""
	)
	// -- Checking Main Device Features
	// -- DMPAC DOF
	Var.IF ((((\Main_Device_Feature_0)&0x100)>>0x8)!=0)
	(
		PRINT "DMPAC Dense Optical Flow disabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "DMPAC Dense Optical Flow enabled via eFuse. "
		PRINT ""
	)
	// -- DMPAC SDE
	Var.IF ((((\Main_Device_Feature_0)&0x200)>>0x9)!=0)
	(
		PRINT "DMPAC Stereo Disparity Engine disabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "DMPAC Stereo Disparity Engine enabled via eFuse. "
		PRINT ""
	)
	// -- SA2_UL SHA/MD5
	Var.IF ((((\Main_Device_Feature_0)&0x10000)>>0x10)!=0)
	(
		PRINT "SA2_UL SHA/MD5 enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "SA2_UL SHA/MD5 disabled via eFuse. "
		PRINT ""
	)
	// -- SA2_UL AES/3DS/DBRG
	Var.IF ((((\Main_Device_Feature_0)&0x20000)>>0x11)!=0)
	(
		PRINT "SA2_UL AES/3DS/DBRG enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "SA2_UL AES/3DS/DBRG disabled via eFuse. "
		PRINT ""
	)
	// -- SA2_UL PKA
	Var.IF ((((\Main_Device_Feature_0)&0x40000)>>0x12)!=0)
	(
		PRINT "SA2_UL PKA enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "SA2_UL PKA disabled via eFuse. "
		PRINT ""
	)
	// -- eDP Crypto
	Var.IF ((((\Main_Device_Feature_0)&0x100000)>>0x14)!=0)
	(
		PRINT "eDP HDCP Cryptography disabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "eDP HDCP Cryptography enabled via eFuse. "
		PRINT ""
	)
	// -- UFS AES
	Var.IF ((((\Main_Device_Feature_0)&0x1000000)>>0x18)!=0)
	(
		PRINT "UFS AES enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		PRINT "UFS AES disabled via eFuse. "
		PRINT ""
	)
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getCryptoFeature_En_Status()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the hardware cryptography configuration by reading the MMRs 
// --  * holding the efuse values from PORz (cold reset). 
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

J7AEP_getCryptoFeature_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \MAIN_Features_Stat
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	// -- Main CTRL MMRs use the offset of 0x8000_0000.
	GOSUB Read_MMR (&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_MAIN_FEATURE_STAT_0)
	ENTRY &__V52
	Var.Assign \MAIN_Features_Stat=&__V52
	PRINT "** J7AEP SA2_UL Cryptological Features: **"
	PRINT ""
	PRINT ""
	PRINT "Crypto Feature Status on this chip: "
	PRINT ""
	Var.IF ((((\MAIN_Features_Stat)&0x40000)>>0x12)==0)
	(
		PRINT "SA2_UL Crypto Module PKA Enabled"
		PRINT ""
	)
	Var.IF ((((\MAIN_Features_Stat)&0x40000)>>0x12)!=0)
	(
		PRINT "SA2_UL Crypto Module PKA Disabled"
		PRINT ""
	)
	Var.IF ((((\MAIN_Features_Stat)&0x20000)>>0x11)==0)
	(
		PRINT "SA2_UL Crypto Module AES/3DES/DBRG Enabled"
		PRINT ""
	)
	Var.IF ((((\MAIN_Features_Stat)&0x20000)>>0x11)!=0)
	(
		PRINT "SA2_UL Crypto Module AES/3DES/DBRG Disabled"
		PRINT ""
	)
	Var.IF ((((\MAIN_Features_Stat)&0x10000)>>0x10)==0)
	(
		PRINT "SA2_UL Crypto Module SHA/MD5 Enabled"
		PRINT ""
	)
	Var.IF ((((\MAIN_Features_Stat)&0x10000)>>0x10)!=0)
	(
		PRINT "SA2_UL Crypto Module SHA/MD5 Disabled"
		PRINT ""
	)
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- Get the status of FD for MCU MCAN

J7AEP_getMCANFD_MCU_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_2
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- WKUP CTRL MMRs use the offset of 0x2000_0000.
	// -- Device Feature 2
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE2)+Var.Value(\address_offset))
	ENTRY &__V53
	Var.Assign \WKUP_Device_Feature_2=&__V53
	Var.IF (((\WKUP_Device_Feature_2)&0x1)!=0)
	(
		// -- If the bit is set, that means the eFuse for MCAN0 FD is 0 AKA burned.
		PRINT "MCAN FD/real-time functionality enabled. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "MCAN FD/real-time functionality disabled. "
		PRINT ""
	)
	// -- address_offset = 0x20000000;
	RETURN
)
// --  Function: J7AEP_getMCANFD_Main_En_Status()
// --  * parameters: unsigned int address_offset
// --  * brief: Determine whether FD mode is enabled for 
// --  * main CAN interfaces. 
// --  * return: 0/no important value
// --  * NOTE: This is not indicated in Main Control MMRs 

J7AEP_getMCANFD_Main_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	// -- No value to read for this value.
	&__FUNCTION_RETURN_VALUE=Var.VALUE(0x0)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)

J7AEP_getDecoder_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_4
	PRINT "Checking for Decoder status"
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE4)+Var.Value(\address_offset))
	ENTRY &__V54
	Var.Assign \WKUP_Device_Feature_4=&__V54
	Var.IF ((((\WKUP_Device_Feature_4)&0x2000000)>>0x19)!=0)
	(
		// -- If the bit is set, that means the eFuse for Decoder is 0 AKA not burned.
		PRINT "Decoder enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Decoder disabled via eFuse. "
		PRINT ""
	)
	RETURN
)

J7AEP_getEncoder_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \WKUP_Device_Feature_4
	PRINT "Checking for Decoder status"
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_DEVICE_FEATURE4)+Var.Value(\address_offset))
	ENTRY &__V55
	Var.Assign \WKUP_Device_Feature_4=&__V55
	Var.IF ((((\WKUP_Device_Feature_4)&0x1000000)>>0x18)!=0)
	(
		// -- If the bit is set, that means the eFuse for Encoder is 0 AKA not burned.
		PRINT "Encoder enabled via eFuse. "
		PRINT ""
	)
	ELSE
	(
		// -- If the bit is not set, that means the eFuse is blown (eFuse is set).
		PRINT "Encoder disabled via eFuse. "
		PRINT ""
	)
	RETURN
)
// -- LVCMOS drive strength

J7AEP_getHorizontal_Drive_Strength_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Horizontal_Drive_Strength_3to0
	Var.NEWLOCAL unsigned int \Horizontal_Drive_Strength_7to4
	Var.NEWLOCAL unsigned int \Horizontal_Drive_Strength_11to8
	Var.NEWLOCAL unsigned int \Horizontal_Drive_Strength_15to12
	Var.NEWLOCAL unsigned int \Vertical_Drive_Strength_3to0
	Var.NEWLOCAL unsigned int \Vertical_Drive_Strength_7to4
	Var.NEWLOCAL unsigned int \Vertical_Drive_Strength_11to8
	Var.NEWLOCAL unsigned int \Vertical_Drive_Strength_15to12
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	PRINT "Getting Horizontal Drive Strength parameters..."
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40C0)+Var.Value(\address_offset))
	ENTRY &__V56
	Var.Assign \Horizontal_Drive_Strength_3to0=&__V56
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40C4)+Var.Value(\address_offset))
	ENTRY &__V57
	Var.Assign \Horizontal_Drive_Strength_7to4=&__V57
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40C8)+Var.Value(\address_offset))
	ENTRY &__V58
	Var.Assign \Horizontal_Drive_Strength_11to8=&__V58
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40CC)+Var.Value(\address_offset))
	ENTRY &__V59
	Var.Assign \Horizontal_Drive_Strength_15to12=&__V59
	PRINT "Horizontal drive strength parameters: "
	PRINT ""
	AREA.Select
	PRINT "Horizontal_Drive_Strength_3to0: " %DECIMAL Var.VALUE(\Horizontal_Drive_Strength_3to0) ""
	PRINT ""
	AREA.Select
	PRINT "Horizontal_Drive_Strength_7to4: " %DECIMAL Var.VALUE(\Horizontal_Drive_Strength_7to4) ""
	PRINT ""
	AREA.Select
	PRINT "Horizontal_Drive_Strength_11to8: " %DECIMAL Var.VALUE(\Horizontal_Drive_Strength_11to8) ""
	PRINT ""
	AREA.Select
	PRINT "Horizontal_Drive_Strength_15to12: " %DECIMAL Var.VALUE(\Horizontal_Drive_Strength_15to12) ""
	PRINT ""
	PRINT "Getting Vertical Drive Strength parameters..."
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40D0)+Var.Value(\address_offset))
	ENTRY &__V60
	Var.Assign \Vertical_Drive_Strength_3to0=&__V60
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40D4)+Var.Value(\address_offset))
	ENTRY &__V61
	Var.Assign \Vertical_Drive_Strength_7to4=&__V61
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40D8)+Var.Value(\address_offset))
	ENTRY &__V62
	Var.Assign \Vertical_Drive_Strength_11to8=&__V62
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x40DC)+Var.Value(\address_offset))
	ENTRY &__V63
	Var.Assign \Vertical_Drive_Strength_15to12=&__V63
	PRINT "Vertical drive strength parameters: "
	PRINT ""
	AREA.Select
	PRINT "Vertical_Drive_Strength_3to0: " %DECIMAL Var.VALUE(\Vertical_Drive_Strength_3to0) ""
	PRINT ""
	AREA.Select
	PRINT "Vertical_Drive_Strength_7to4: " %DECIMAL Var.VALUE(\Vertical_Drive_Strength_7to4) ""
	PRINT ""
	AREA.Select
	PRINT "Vertical_Drive_Strength_11to8: " %DECIMAL Var.VALUE(\Vertical_Drive_Strength_11to8) ""
	PRINT ""
	AREA.Select
	PRINT "Vertical_Drive_Strength_15to12: " %DECIMAL Var.VALUE(\Vertical_Drive_Strength_15to12) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getICSSGMainFeature_En_Status()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the ICSSG hardware configuration by reading the MMRs 
// --  * holding the efuse values from PORz (cold reset). 

J7AEP_getICSSGMainFeature_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \ICSSG0_Features
	Var.NEWLOCAL unsigned int \ICSSG1_Features
	Var.NEWLOCAL unsigned int \ICSSG2_Features
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG0_DISABLE_STAT)+Var.Value(\address_offset))
	ENTRY &__V64
	Var.Assign \ICSSG0_Features=&__V64
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG1_DISABLE_STAT)+Var.Value(\address_offset))
	ENTRY &__V65
	Var.Assign \ICSSG1_Features=&__V65
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+&__CSL_MAIN_CTRL_MMR_CFG0_ICSSG2_DISABLE_STAT)+Var.Value(\address_offset))
	ENTRY &__V66
	Var.Assign \ICSSG2_Features=&__V66
	PRINT "** J7AEP ICSSG Hardware-Disable eFuses: **"
	PRINT ""
	PRINT ""
	Var.IF (((\ICSSG0_Features)&0x3)==0x3)
	(
		// -- Both fuses are blown for EtherCAT on ICSSG0
		PRINT "EtherCAT disabled on ICSSG0."
		PRINT ""
	)
	ELSE
	(
		PRINT "EtherCAT enabled on ICSGG0."
		PRINT ""
	)
	Var.IF (((\ICSSG1_Features)&0x3)==0x3)
	(
		// -- Both fuses are blown for EtherCAT on ICSSG1
		PRINT "EtherCAT disabled on ICSSG1."
		PRINT ""
	)
	ELSE
	(
		PRINT "EtherCAT enabled on ICSSG1."
		PRINT ""
	)
	Var.IF (((\ICSSG2_Features)&0x3)==0x3)
	(
		// -- Both fuses are blown for EtherCAT on ICSSG2
		PRINT "EtherCAT disabled on ICSSG2."
		PRINT ""
	)
	ELSE
	(
		PRINT "EtherCAT enabled on ICSSG2."
		PRINT ""
	)
	// -- GEL_TextOut("ICSSG0 Hardware features are disabled according to this register: %x\n",,,,, ICSSG0_Features);
	// -- GEL_TextOut("ICSSG1 Hardware features are disabled according to this register: %x\n",,,,, ICSSG1_Features);
	// -- GEL_TextOut("ICSSG2 Hardware features are disabled according to this register: %x\n",,,,, ICSSG2_Features);
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_getR5FLockstep_En_Status()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the R5F safety hardware configuration by reading the MMRs 
// --  * holding the efuse values from PORz (cold reset). 
// --  Note: With regards to the M3, the MCU Security MMRs are within the region
// --  * 0x4400_0000 -- 0x45FF_FFFF (WKUP CBASS: DMSC Slave Region). No address
// --  * offset is needed here.
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

J7AEP_getR5FLockstep_En_Status:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \MCU_Cluster0_Config_MMR
	Var.NEWLOCAL unsigned int \Main_Cluster0_Config_MMR
	Var.NEWLOCAL unsigned int \Main_Cluster1_Config_MMR
	GOSUB Read_MMR (&__CSL_MCU_SEC_MMR0_CFG0_BASE+0x40)
	ENTRY &__V67
	Var.Assign \MCU_Cluster0_Config_MMR=&__V67
	GOSUB Read_MMR (&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE+0x40)
	ENTRY &__V68
	Var.Assign \Main_Cluster0_Config_MMR=&__V68
	GOSUB Read_MMR (&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE+0x1040)
	ENTRY &__V69
	Var.Assign \Main_Cluster1_Config_MMR=&__V69
	PRINT "** J7AEP R5F Lockstep Information: **"
	PRINT ""
	PRINT ""
	PRINT "R5F Lockstep Status: "
	PRINT ""
	Var.IF ((((\MCU_Cluster0_Config_MMR)&0x8)>>0x3)!=0)
	(
		// -- Bit 3 is set- fuse is blown. Lockstep is supported on the device as per the MCU SEC MMR spec
		PRINT "MCU R5F Lockstep operation is supported on this device."
		PRINT ""
	)
	ELSE
	(
		PRINT "MCU R5F Lockstep operation is not supported on this device. "
		PRINT ""
	)
	Var.IF (((\MCU_Cluster0_Config_MMR)&0x1)==0x1)
	(
		// -- Bit 0 is set. Lockstep operation is active.
		PRINT "MCU R5F Lockstep operation is active."
		PRINT ""
		PRINT "This is just the eFuse value from PORz."
		PRINT ""
		PRINT "Users can disable lockstep action by writing a 0 to this register at offset 0x40 in MCU_SEC_MMR."
		PRINT ""
		PRINT "Just make sure not to burn the eFuse if you want lockstep"
		PRINT ""
	)
	Var.IF ((((\Main_Cluster0_Config_MMR)&0x8)>>0x3)!=0)
	(
		// -- Bit 3 is set- fuse is blown. Lockstep is supported on the device as per the MCU SEC MMR spec
		PRINT "Main Cluster 0 R5F Lockstep operation is supported on this device."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 0 R5F Lockstep operation is not supported on this device. "
		PRINT ""
	)
	Var.IF (((\Main_Cluster0_Config_MMR)&0x1)==0x1)
	(
		// -- Bit 0 is set. Lockstep operation is active.
		PRINT "Main Cluster 0 R5F Lockstep operation is active."
		PRINT ""
		PRINT "This is just the eFuse value from PORz."
		PRINT ""
		PRINT "Users can disable lockstep action by writing a 0 to this register at offset 0x40 in MAIN_SEC_MMR."
		PRINT ""
		PRINT "Just make sure not to burn the eFuse if you want lockstep"
		PRINT ""
	)
	Var.IF ((((\Main_Cluster1_Config_MMR)&0x8)>>0x3)!=0)
	(
		// -- Bit 3 is set- fuse is blown. Lockstep is supported on the device as per the MCU SEC MMR spec
		PRINT "Main Cluster 1 R5F Lockstep operation is supported on this device."
		PRINT ""
	)
	ELSE
	(
		PRINT "Main Cluster 1 R5F Lockstep operation is not supported on this device. "
		PRINT ""
	)
	Var.IF (((\Main_Cluster1_Config_MMR)&0x1)==0x1)
	(
		// -- Bit 0 is set. Lockstep operation is active.
		PRINT "Main Cluster 1 R5F Lockstep operation is active."
		PRINT ""
		PRINT "This is just the eFuse value from PORz."
		PRINT ""
		PRINT "Users can disable lockstep action by writing a 0 to this register at offset 0x1040 in MAIN_SEC_MMR."
		PRINT ""
		PRINT "Just make sure not to burn the eFuse if you want lockstep"
		PRINT ""
	)
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)

J7AEP_getMainPORZTimeout:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \timeout_period
	PRINT "Checking Main PORz timeout period"
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0x18104)
	ENTRY &__V70
	Var.Assign \timeout_period=&__V70
	Var.IF ((\timeout_period)==0x0)
	(
		PRINT "Timeout period is immediate."
		PRINT ""
	)
	ELSE
	(
		Var.IF ((\timeout_period)==0x1)
		(
			PRINT "Timeout period is 100us."
			PRINT ""
		)
		ELSE
		(
			Var.IF ((\timeout_period)==0x2)
			(
				PRINT "Timeout period is 200us."
				PRINT ""
			)
			ELSE
			(
				Var.IF ((\timeout_period)==0x3)
				(
					PRINT "Timeout period is 300us."
					PRINT ""
				)
				ELSE
				(
					Var.IF ((\timeout_period)==0x4)
					(
						PRINT "Timeout period is 400us."
						PRINT ""
					)
					ELSE
					(
						Var.IF ((\timeout_period)==0x5)
						(
							PRINT "Timeout period is 500us."
							PRINT ""
						)
					)
				)
			)
		)
	)
	RETURN
)
// --  Function: J7AEP_ReadRC12MOSCeFuses()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the 12.5MHz RC oscillator tuning configuration by reading the MMRs 
// --  * holding the efuse values from PORz (cold reset). 
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

J7AEP_ReadRC12MOSCeFuses:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \RC12M_Osc_Trim
	// -- If this statement is true we're running from the CM3 DMSC.
	// -- Make sure to account for the address offset.
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- WKUP CTRL MMRs use the offset of 0x2000_0000.
	PRINT "J7AEP 12.5MHz RC Oscillator Information: "
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+&__CSL_WKUP_CTRL_MMR_CFG0_RC12M_OSC_TRIM)+Var.Value(\address_offset))
	ENTRY &__V71
	Var.Assign \RC12M_Osc_Trim=&__V71
	PRINT "12.5 MHz RC Oscillator Trim Values: "
	PRINT ""
	AREA.Select
	PRINT "Coarse Adjustment Direction: " %HEX Var.VALUE(((\RC12M_Osc_Trim&0x40)>>0x6)) ""
	PRINT ""
	PRINT "If that bit is 0, the adjustment will decrease the frequency."
	PRINT ""
	PRINT "If that bit is 1, the adjustment will increase the frequency."
	PRINT ""
	AREA.Select
	PRINT "Coarse Adjustment Amount (x1.25MHz): " %HEX Var.VALUE(((\RC12M_Osc_Trim&0x38)>>0x3)) ""
	PRINT ""
	AREA.Select
	PRINT "Fine Adjustment Amount (x250kHz): " %HEX Var.VALUE(\RC12M_Osc_Trim) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// --  Function: J7AEP_ReadSecManagerDeviceType()
// --  * parameters: unsigned int address_offset
// --  * brief: Obtain the device type information by reading the MMRs 
// --  * holding the efuse values for device type from PORz (cold reset). 
// --  Note: Security Manager is inside the DMSC CBASS so users don't have to worry
// --  * about trying to account for any offset- the M3 RAT Won't decode addresses
// --  * within the range of 0x4400_0000 <--> 0x45FF_FFFF. 
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

J7AEP_ReadSecManagerDeviceType:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \Device_Type
	Var.NEWLOCAL unsigned int \SECMGR_Sys_status
	Var.NEWLOCAL unsigned int \SECMGR_FSM_status
	Var.NEWLOCAL unsigned int \SECMGR_Efuse_status
	PRINT "** J7AEP Device Type Status: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR (&__CSL_WKUP_DMSC0_SECMGR_BASE+&__SEC_MGR_SYSTEM_STAT)
	ENTRY &__V72
	Var.Assign \Device_Type=&__V72
	PRINT "J7AEP Device Type is as follows: "
	PRINT ""
	Var.IF (((\Device_Type)&0xF)==0x5)
	(
		// -- TEST
		PRINT "Device Type: TEST"
		PRINT ""
	)
	ELSE
	(
		Var.IF (((\Device_Type)&0xF)==0x9)
		(
			// -- EMULATOR
			PRINT "Device Type: EMULATOR"
			PRINT ""
		)
		ELSE
		(
			Var.IF (((\Device_Type)&0xF)==0xA)
			(
				// -- HS
				PRINT "Device Type: HIGH SECURITY"
				PRINT ""
				Var.IF (((\Device_Type)&0xF00)==0xA)
				(
					// -- HS-FS
					PRINT "High Security Type: Field-Securable (HS-FS)"
					PRINT ""
				)
				ELSE
				(
					// -- HS-SE
					PRINT "High Security Type: Security Enforced (HS-SE)"
					PRINT ""
				)
			)
			ELSE
			(
				Var.IF (((\Device_Type)&0xF)==0x3)
				(
					// -- GP
					PRINT "Device Type: GENERAL-PURPOSE"
					PRINT ""
				)
				ELSE
				(
					// -- BAD
					PRINT "Device Type: BAD"
					PRINT ""
				)
			)
		)
	)
	// -- Wait for security efuses to be ready
	// -- GEL_TextOut("Wait for security eFuses to be ready.\n");
	// -- We only need to grab the master keys (TI keys), so MEK, MPK, and KEK are all keys we have to look for.
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- Read POST and BIST eFuse values

J7AEP_ReadPOSTandBISTValues:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \address_offset=&__VF0
	Var.NEWLOCAL unsigned int \DMSC_LBIST_Control
	Var.NEWLOCAL unsigned int \DMSC_Pattern_Count
	Var.NEWLOCAL unsigned int \DMSC_LBIST_Seed_0
	Var.NEWLOCAL unsigned int \DMSC_LBIST_Seed_1
	Var.NEWLOCAL unsigned int \DMSC_MISR_Signature
	Var.NEWLOCAL unsigned int \MCU_LBIST_Control
	Var.NEWLOCAL unsigned int \MCU_Pattern_Count
	Var.NEWLOCAL unsigned int \MCU_LBIST_Seed_0
	Var.NEWLOCAL unsigned int \MCU_LBIST_Seed_1
	Var.NEWLOCAL unsigned int \MCU_MISR_Signature
	Var.NEWLOCAL unsigned int \POST_Options
	Var.NEWLOCAL unsigned int \POST_Selection_Status
	Var.NEWLOCAL unsigned int \WKUP_POST_Configuration
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- WKUP/MCU CTRL MMRs use the offset of 0x2000_0000.
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC000)
	ENTRY &__V73
	Var.Assign \DMSC_LBIST_Control=&__V73
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC004)
	ENTRY &__V74
	Var.Assign \DMSC_Pattern_Count=&__V74
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC008)
	ENTRY &__V75
	Var.Assign \DMSC_LBIST_Seed_0=&__V75
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC00C)
	ENTRY &__V76
	Var.Assign \DMSC_LBIST_Seed_1=&__V76
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC280)
	ENTRY &__V77
	Var.Assign \DMSC_MISR_Signature=&__V77
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC000)
	ENTRY &__V78
	Var.Assign \MCU_LBIST_Control=&__V78
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC004)
	ENTRY &__V79
	Var.Assign \MCU_Pattern_Count=&__V79
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC008)
	ENTRY &__V80
	Var.Assign \MCU_LBIST_Seed_0=&__V80
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC00C)
	ENTRY &__V81
	Var.Assign \MCU_LBIST_Seed_1=&__V81
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC280)
	ENTRY &__V82
	Var.Assign \MCU_MISR_Signature=&__V82
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0x3C)
	ENTRY &__V83
	Var.Assign \POST_Options=&__V83
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0x38)
	ENTRY &__V84
	Var.Assign \POST_Selection_Status=&__V84
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+(Var.VALUE(\address_offset)))+0xC2C4)
	ENTRY &__V85
	Var.Assign \WKUP_POST_Configuration=&__V85
	PRINT "Checking POST/BIST values."
	PRINT ""
	AREA.Select
	PRINT "DMSC LBIST Control MMR value: " %HEX Var.VALUE(\DMSC_LBIST_Control) ""
	PRINT ""
	PRINT "DMSC Load Divide bit: Taken out of LBIST control register."
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_dc_def:       " %DECIMAL Var.VALUE(((\DMSC_LBIST_Control&0x00000300)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_runbist_mode: " %DECIMAL Var.VALUE(((\DMSC_LBIST_Control&0x0000F000)>>0xC)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_bist_run:     " %DECIMAL Var.VALUE(((\DMSC_LBIST_Control&0x0F000000)>>0x18)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_reset:        " %DECIMAL Var.VALUE(((\DMSC_LBIST_Control&0x80000000)>>0x1F)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_scan_pc_def:  " %DECIMAL Var.VALUE((\DMSC_Pattern_Count&0xF)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_reset_pc_def: " %DECIMAL Var.VALUE(((\DMSC_Pattern_Count&0xF0)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_set_pc_def:   " %DECIMAL Var.VALUE(((\DMSC_Pattern_Count&0xF00)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_static_pc_def " %HEX Var.VALUE(((\DMSC_Pattern_Count&0x3FFF0000)>>0x10)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_prpg_def:     " %HEX Var.VALUE(\DMSC_LBIST_Seed_1) "_" %HEX Var.VALUE(\DMSC_LBIST_Seed_0) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_dmsc_misr_sig:     " %HEX Var.VALUE(\DMSC_MISR_Signature) ""
	PRINT ""
	AREA.Select
	PRINT "MCU Control MMR value: " %HEX Var.VALUE(\MCU_LBIST_Control) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_divide_ratio: " %DECIMAL Var.VALUE((\MCU_LBIST_Control&0x1F)) ""
	PRINT ""
	AREA.Select
	PRINT "ek_wkup_mcu_load_div:     " %DECIMAL Var.VALUE(((\MCU_LBIST_Control&0x80)>>0x7)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_dc_def:       " %DECIMAL Var.VALUE(((\MCU_LBIST_Control&0x00000300)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_runbist_mode: " %DECIMAL Var.VALUE(((\MCU_LBIST_Control&0x0000F000)>>0xC)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_bist_run:     " %DECIMAL Var.VALUE(((\MCU_LBIST_Control&0x0F000000)>>0x18)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_reset:        " %DECIMAL Var.VALUE(((\MCU_LBIST_Control&0x80000000)>>0x1F)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_scan_pc_def:  " %DECIMAL Var.VALUE((\MCU_Pattern_Count&0xF)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_reset_pc_def: " %DECIMAL Var.VALUE(((\MCU_Pattern_Count&0xF0)>>0x4)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_set_pc_def:   " %DECIMAL Var.VALUE(((\MCU_Pattern_Count&0xF00)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_static_pc_def " %HEX Var.VALUE(((\MCU_Pattern_Count&0x3FFF0000)>>0x10)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_prpg_def:     " %HEX Var.VALUE(\MCU_LBIST_Seed_1) "_" %HEX Var.VALUE(\MCU_LBIST_Seed_0) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_mcu_misr_sig:     " %HEX Var.VALUE(\MCU_MISR_Signature) ""
	PRINT ""
	AREA.Select
	PRINT "POST Options Register value: " %HEX Var.VALUE(\POST_Options) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_lbist_parallel_1: " %DECIMAL Var.VALUE((\POST_Options&0x1)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_dmsc_lbist_1:     " %DECIMAL Var.VALUE(((\POST_Options&0x2)>>0x1)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_lbist_1:      " %DECIMAL Var.VALUE(((\POST_Options&0x4)>>0x2)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_pbist_1:      " %DECIMAL Var.VALUE(((\POST_Options&0x8)>>0x3)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_lbist_parallel_2: " %DECIMAL Var.VALUE(((\POST_Options&0x100)>>0x8)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_dmsc_lbist_2:     " %DECIMAL Var.VALUE(((\POST_Options&0x200)>>0x9)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_lbist_2:      " %DECIMAL Var.VALUE(((\POST_Options&0x400)>>0xA)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_pbist_2:      " %DECIMAL Var.VALUE(((\POST_Options&0x800)>>0xB)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_lbist_parallel_3: " %DECIMAL Var.VALUE(((\POST_Options&0x10000)>>0x10)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_dmsc_lbist_3:     " %DECIMAL Var.VALUE(((\POST_Options&0x20000)>>0x11)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_lbist_3:      " %DECIMAL Var.VALUE(((\POST_Options&0x40000)>>0x12)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_en_mcu_pbist_3:      " %DECIMAL Var.VALUE(((\POST_Options&0x80000)>>0x13)) ""
	PRINT ""
	AREA.Select
	PRINT "POST_SEL_STAT value: " %HEX Var.VALUE(\POST_Selection_Status) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_post_sel: " %HEX Var.VALUE((\POST_Selection_Status&0x1)) ""
	PRINT ""
	AREA.Select
	PRINT "WKUP_POST_CFG value: " %HEX Var.VALUE(\WKUP_POST_Configuration) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_fast_post_en:           " %DECIMAL Var.VALUE(((\WKUP_POST_Configuration&0x80000000)>>0x1F)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_fast_post_pll_postdiv1: " %DECIMAL Var.VALUE(((\WKUP_POST_Configuration&0x07000000)>>0x18)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_fast_post_pll_postdiv2: " %DECIMAL Var.VALUE(((\WKUP_POST_Configuration&0x70000000)>>0x1C)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_fast_post_pll_refdiv:   " %DECIMAL Var.VALUE(((\WKUP_POST_Configuration&0x00070000)>>0x10)) ""
	PRINT ""
	AREA.Select
	PRINT "ef_wkup_fast_post_pll_fbdiv:    " %HEX Var.VALUE((\WKUP_POST_Configuration&0x7FF)) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- NEW functions //TODO test this
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_Main_Control_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \Main_PID
	Var.NEWLOCAL unsigned int \Main_config0
	Var.NEWLOCAL unsigned int \Main_config1
	Var.NEWLOCAL unsigned int \address_offset
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	// -- Main CTRL MMRs use the offset of 0x8000_0000.
	PRINT "** J7AEP MCU CTRL MMRs PID/CFG Check: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+0x0)+Var.Value(\address_offset))
	ENTRY &__V86
	Var.Assign \Main_PID=&__V86
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+0x4)+Var.Value(\address_offset))
	ENTRY &__V87
	Var.Assign \Main_config0=&__V87
	GOSUB Read_MMR ((&__CSL_MAIN_CTRL_MMR0_CFG0_BASE+0x8)+Var.Value(\address_offset))
	ENTRY &__V88
	Var.Assign \Main_config1=&__V88
	AREA.Select
	PRINT "Main CTRL MMR PID MMR: " %HEX Var.VALUE(\Main_PID) ""
	PRINT ""
	AREA.Select
	PRINT "Main CTRL MMR Config 0 MMR: " %HEX Var.VALUE(\Main_config0) ""
	PRINT ""
	AREA.Select
	PRINT "Main CTRL MMR Config 1 MMR: " %HEX Var.VALUE(\Main_config1) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- Check the PID for the Main PLL MMR //TODO TEST THIS
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_Main_PLL_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \Main_PLL_MMR_PID
	Var.NEWLOCAL unsigned int \Main_PLL_config0
	Var.NEWLOCAL unsigned int \Main_PLL_config1
	Var.NEWLOCAL unsigned int \address_offset
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	// -- Main PLL MMRs use the offset of 0x8000_0000.
	PRINT "** J7AEP Main PLL MMRs PID Check: **"
	PRINT ""
	PRINT ""
        GOSUB Read_MMR ((Var.VALUE(\PLL_MMR1_CFG_BASE)+0x0)+Var.Value(\address_offset))
	ENTRY &__V89
	Var.Assign \Main_PLL_MMR_PID=&__V89
	GOSUB Read_MMR ((Var.VALUE(\PLL_MMR1_CFG_BASE)+0x8)+Var.Value(\address_offset))
	ENTRY &__V90
	Var.Assign \Main_PLL_config0=&__V90
	GOSUB Read_MMR ((Var.VALUE(\PLL_MMR1_CFG_BASE)+0xC)+Var.Value(\address_offset))
	ENTRY &__V91
	Var.Assign \Main_PLL_config1=&__V91
	AREA.Select
	PRINT "Main PLL MMR PID: " %HEX Var.VALUE(\Main_PLL_MMR_PID) ""
	PRINT ""
	AREA.Select
	PRINT "Main PLL MMR Config 0 MMR: " %HEX Var.VALUE(\Main_PLL_config0) ""
	PRINT ""
	AREA.Select
	PRINT "Main PLL MMR Config 1 MMR: " %HEX Var.VALUE(\Main_PLL_config1) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- TODO test this
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_MCU_Control_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \MCU_MMRs_PID
	Var.NEWLOCAL unsigned int \MCU_MMRs_config0
	Var.NEWLOCAL unsigned int \MCU_MMRs_config1
	Var.NEWLOCAL unsigned int \address_offset
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- MCU CTRL MMRs use the offset of 0x2000_0000.
	PRINT "** J7AEP MCU CTRL MMRs PID/CFG Check: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+0x0)+Var.Value(\address_offset))
	ENTRY &__V92
	Var.Assign \MCU_MMRs_PID=&__V92
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+0x4)+Var.Value(\address_offset))
	ENTRY &__V93
	Var.Assign \MCU_MMRs_config0=&__V93
	GOSUB Read_MMR ((&__CSL_MCU_CTRL_MMR0_CFG0_BASE+0x8)+Var.Value(\address_offset))
	ENTRY &__V94
	Var.Assign \MCU_MMRs_config1=&__V94
	AREA.Select
	PRINT "MCU CTRL MMR PID MMR: " %HEX Var.VALUE(\MCU_MMRs_PID) ""
	PRINT ""
	AREA.Select
	PRINT "MCU CTRL MMR Config 0 MMR: " %HEX Var.VALUE(\MCU_MMRs_config0) ""
	PRINT ""
	AREA.Select
	PRINT "MCU CTRL MMR Config 1 MMR: " %HEX Var.VALUE(\MCU_MMRs_config1) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- TODO test this
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_MCU_PLL_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \MCU_PLL_MMR_PID
	Var.NEWLOCAL unsigned int \MCU_PLL_config0
	Var.NEWLOCAL unsigned int \MCU_PLL_config1
	Var.NEWLOCAL unsigned int \address_offset
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- MCU PLL MMRs use the offset of 0x2000_0000.
	PRINT "** J7AEP MCU PLL MMRs PID Check: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__PLL_MMR0_CFG_BASE+0x0)+Var.Value(\address_offset))
	ENTRY &__V95
	Var.Assign \MCU_PLL_MMR_PID=&__V95
	GOSUB Read_MMR ((&__PLL_MMR0_CFG_BASE+0x8)+Var.Value(\address_offset))
	ENTRY &__V96
	Var.Assign \MCU_PLL_config0=&__V96
	GOSUB Read_MMR ((&__PLL_MMR0_CFG_BASE+0xC)+Var.Value(\address_offset))
	ENTRY &__V97
	Var.Assign \MCU_PLL_config1=&__V97
	AREA.Select
	PRINT "MCU PLL MMR PID: " %HEX Var.VALUE(\MCU_PLL_MMR_PID) ""
	PRINT ""
	AREA.Select
	PRINT "MCU PLL MMR Config 0 value: " %HEX Var.VALUE(\MCU_PLL_config0) ""
	PRINT ""
	AREA.Select
	PRINT "MCU PLL MMR Config 1 value: " %HEX Var.VALUE(\MCU_PLL_config1) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- TODO test this
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_MCU_SEC_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \MCU_SEC_DEF_MMR
	PRINT "** J7AEP MCU SEC MMRs DEF Check: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR (&__CSL_MCU_SEC_MMR0_CFG0_BASE+0x20)
	ENTRY &__V98
	Var.Assign \MCU_SEC_DEF_MMR=&__V98
	AREA.Select
	PRINT "MCU SEC MMR DEF MMR value: " %HEX Var.VALUE(\MCU_SEC_DEF_MMR) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- TODO test this
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none

Read_WKUP_Control_MMR_ID_Config_Regs:
(
	Var.NEWLOCAL unsigned int \WKUP_control_MMR_PID
	Var.NEWLOCAL unsigned int \WKUP_control_config0
	Var.NEWLOCAL unsigned int \WKUP_control_config1
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign &__address_offset=Var.VALUE(0x20000000)
	)
	// -- WKUP CTRL MMRs use the offset of 0x2000_0000.
	PRINT "** J7AEP WKUP CTRP MMRs PID/CFG Check: **"
	PRINT ""
	PRINT ""
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x0)+Var.Value(\address_offset))
	ENTRY &__V99
	Var.Assign \WKUP_control_MMR_PID=&__V99
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x4)+Var.Value(\address_offset))
	ENTRY &__V100
	Var.Assign \WKUP_control_config0=&__V100
	GOSUB Read_MMR ((&__CSL_WKUP_CTRL_MMR0_CFG0_BASE+0x8)+Var.Value(\address_offset))
	ENTRY &__V101
	Var.Assign \WKUP_control_config1=&__V101
	AREA.Select
	PRINT "WKUP PLL MMR PID: " %HEX Var.VALUE(\WKUP_control_MMR_PID) ""
	PRINT ""
	AREA.Select
	PRINT "WKUP PLL MMR Config 0 value: " %HEX Var.VALUE(\WKUP_control_config0) ""
	PRINT ""
	AREA.Select
	PRINT "WKUP PLL MMR Config 1 value: " %HEX Var.VALUE(\WKUP_control_config1) ""
	PRINT ""
	PRINT "**** End of section ****"
	PRINT ""
	PRINT ""
	RETURN
)
// -- Read the PLL Trim registers //TODO: finish this if PE team needs more PLL eFuse readings
// -- *
// --  * \brief   brief description here.
// --  *
// --  * \param   dummy_param used
// --  *
// --  * \return  none
// -- Read_PLL_Trim_MMRs(){
// -- 	unsigned int Main_PLL0_trim;	//Main
// -- 	unsigned int Main_PLL1_trim;	//Per0
// -- 	unsigned int Main_PLL2_trim;	//Per1
// -- 	unsigned int Main_PLL3_trim;	//DDR
// -- 	unsigned int Main_PLL4_trim;	//DSS
// -- 	unsigned int Main_PLL6_trim;	//ARM0
// -- 	unsigned int Main_PLL7_trim;	//ARM1
// -- 	//If this statement is true we're running from the CM3 DMSC.
// -- 	//Make sure to account for the address offset.
// -- 	if (*((unsigned int*)WAKEUP_PSC_BASE) != PSC_PID)
// --     {
// --         address_offset = 0x80000000;
// --     } //Main PLL MMRs use the offset of 0x8000_0000.
// -- 	GEL_TextOut("** J7AEP PLL Trim Values PID Check: **\n\n");
// -- }
// --  END OF FILE 
// --  ************************************************************************* 
// --  Global Helper Functions 
// --  ************************************************************************* 
// --  Read from an MMR. 

Read_MMR:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL unsigned int \mmr_address=&__VF0
	Var.NEWLOCAL unsigned int * \p_mmr
	Var.Assign \p_mmr=((unsigned int *)\mmr_address)
	&__FUNCTION_RETURN_VALUE=Var.Value(*\p_mmr)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)

__GeL_MeNu_CrEaTe:
(
	MENU.ReProgram
	(
		ADD
		MENU
		(
			POPUP "GEL"
			(
				POPUP "Read eFuse values"
				(
					MENUITEM "Read_All_Global_Device_Information" 
					(
						DO "&path_J7AEP_eFuse_cmm" Read_All_Global_Device_Information
					)
					MENUITEM "Read_Critical_eFuse_Information_for_BringUp" 
					(
						DO "&path_J7AEP_eFuse_cmm" Read_Critical_eFuse_Information_for_BringUp
					)
					MENUITEM "Read_SoC_MMR_ID_Registers" 
					(
						DO "&path_J7AEP_eFuse_cmm" Read_SoC_MMR_ID_Registers
					)
					MENUITEM "Read_POST_and_BIST_eFuse_Values" 
					(
						DO "&path_J7AEP_eFuse_cmm" Read_POST_and_BIST_eFuse_Values
					)
				)
			)
		)
	)
	RETURN
)
// -- *
// --  * \brief   Read all eFuse values across all control MMRs upon PORz.
// --  *
// --  * \param   none
// --  *
// --  * \return  none

Read_All_Global_Device_Information:
(
	Var.NEWLOCAL unsigned int \address_offset
	// -- Need to account for RAT re-programming
	Var.Assign \address_offset=0x0
	PRINT ""
	PRINT ""
	PRINT "Start of global eFuse check"
	PRINT ""
	PRINT ""
	PRINT "Reading J7AEP Device Information. "
	PRINT ""
	GOSUB J7AEP_getJTAGID Var.VALUE(\address_offset)
	GOSUB J7AEP_getDIEID Var.VALUE(\address_offset)
	GOSUB J7AEP_getMACID Var.VALUE(\address_offset)
	GOSUB J7AEP_ReadSecManagerDeviceType Var.VALUE(\address_offset)
	GOSUB J7AEP_getA72_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getGPU_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getDSP_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getR5F_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getR5FLockstep_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getBootRomConfiguration Var.VALUE(\address_offset)
	GOSUB J7AEP_getHardwareFeature_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getCryptoFeature_En_Status Var.VALUE(\address_offset)
	GOSUB Read_POST_and_BIST_eFuse_Values Var.VALUE(\address_offset)
	PRINT ""
	PRINT ""
	PRINT "End of global eFuse check."
	PRINT ""
	PRINT ""
	RETURN
	
)
// -- *
// --  * \brief   Read all critical eFuses for initial bringup.
// --  *
// --  * \param   none
// --  *
// --  * \return  none

Read_Critical_eFuse_Information_for_BringUp:
(
	Var.NEWLOCAL unsigned int \address_offset
	// -- Need to account for RAT re-programming
	Var.Assign \address_offset=0x0
	PRINT "Reading eFuse values for silicon bringup"
	PRINT ""
	PRINT ""
	PRINT ""
	PRINT "Start of Bring-Up eFuse check"
	PRINT ""
	PRINT ""
	GOSUB J7AEP_getJTAGID Var.VALUE(\address_offset)
	GOSUB J7AEP_getDIEID Var.VALUE(\address_offset)
	GOSUB J7AEP_getMACID Var.VALUE(\address_offset)
	GOSUB J7AEP_ReadSecManagerDeviceType Var.VALUE(\address_offset)
	GOSUB J7AEP_getA72_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getGPU_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getDSP_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getR5F_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getR5FLockstep_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getDecoder_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getEncoder_En_Status Var.VALUE(\address_offset)
	GOSUB J7AEP_getHorizontal_Drive_Strength_En_Status Var.VALUE(\address_offset)
	PRINT ""
	PRINT ""
	PRINT "End of Bring-Up eFuse check."
	PRINT ""
	PRINT ""
	RETURN
	
)
// -- TODO: FIX THIS, IT'S CURRENTLY BROKEN
// -- *
// --  * \brief   Read PID MMRs for all control MMRs.
// --  *
// --  * \param   none
// --  *
// --  * \return  none

Read_SoC_MMR_ID_Registers:
(
	PRINT "Reading ID values for all SoC MMRs"
	PRINT ""
	GOSUB Read_Main_Control_MMR_ID_Config_Regs
	GOSUB Read_Main_PLL_MMR_ID_Config_Regs
	GOSUB Read_MCU_Control_MMR_ID_Config_Regs
	GOSUB Read_MCU_PLL_MMR_ID_Config_Regs
	GOSUB Read_MCU_SEC_MMR_ID_Config_Regs
	GOSUB Read_WKUP_Control_MMR_ID_Config_Regs
	PRINT ""
	PRINT ""
	PRINT "End of SoC MMR ID section"
	PRINT ""
	PRINT ""
	RETURN
	
)

Read_POST_and_BIST_eFuse_Values:
(
	Var.NEWLOCAL unsigned int \address_offset
	// -- Need to account for RAT re-programming
	Var.Assign \address_offset=0x0
	PRINT "Reading POST/BIST values"
	PRINT ""
	GOSUB J7AEP_ReadPOSTandBISTValues Var.VALUE(\address_offset)
	RETURN
	
)
