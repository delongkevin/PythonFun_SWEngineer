LOCAL &function &args
ENTRY &function %LINE &args
// -- *
// --  * \file  J7AEP.gel
// --  *
// --  * \brief GEL File to control and manage other GEL functions for J7AEP
// --  Copyright (c) 2020, Texas Instruments Incorporated
// --  * All rights reserved.
// --  *
// --  * Redistribution and use in source and binary forms, with or without
// --  * modification, are permitted provided that the following conditions
// --  * are met:
// --  *
// --  * *  Redistributions of source code must retain the above copyright
// --  *    notice, this list of conditions and the following disclaimer.
// --  *
// --  * *  Redistributions in binary form must reproduce the above copyright
// --  *    notice, this list of conditions and the following disclaimer in the
// --  *    documentation and/or other materials provided with the distribution.
// --  *
// --  * *  Neither the name of Texas Instruments Incorporated nor the names of
// --  *    its contributors may be used to endorse or promote products derived
// --  *    from this software without specific prior written permission.
// --  *
// --  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// --  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// --  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// --  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// --  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// --  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// --  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// --  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// --  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// --  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// --  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// --  *        Platform: Keystone 3 SoCs
// --  *                     - Jacinto 7  (J7AEP)
// --  *        Usage: This GEL will be run from CCS upon connection to the Cortex-M4F
// --  *               CPU.
// --  *        History:
// --  *          See History.txt
// -- Common Register Definitions
LOCAL &__WAKEUP_PSC_BASE
&__WAKEUP_PSC_BASE=(0x42000000)
LOCAL &__MAIN_PSC_BASE
&__MAIN_PSC_BASE=(0x00400000)
LOCAL &__PSC_PID
&__PSC_PID=(0x44827A00)
LOCAL &__M3_SOC_OFFSET
&__M3_SOC_OFFSET=(0x60000000)
LOCAL &__CSL_MCU_SEC_MMR0_CFG0_BASE
&__CSL_MCU_SEC_MMR0_CFG0_BASE=(0x45A50000)
LOCAL &__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE
&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE=(0x45A40000)
LOCAL &__CSL_WKUP_DMSC0_RAT_BASE
&__CSL_WKUP_DMSC0_RAT_BASE=(0x44200000)
LOCAL &__CSL_COMPUTE_CLUSTER0_DMSC_BOOT_BASE
&__CSL_COMPUTE_CLUSTER0_DMSC_BOOT_BASE=(0x45A00000)
LOCAL &__CSL_WKUP_CTRL_MMR0_CFG0_BASE
&__CSL_WKUP_CTRL_MMR0_CFG0_BASE=(0x43000000)
LOCAL &__PARTITION_4_LOCK_VAL0
&__PARTITION_4_LOCK_VAL0=(0x68EF3490)
LOCAL &__PARTITION_4_LOCK_VAL1
&__PARTITION_4_LOCK_VAL1=(0xD172BC5A)
LOCAL &__DMSC_FLOW
&__DMSC_FLOW=(0.)                  ; ---> For PDK examples this needs to b 1.

// --  END OF FILE 
// -- TIFS_SEC_MMR Register Definition
LOCAL &__TIFS_SEC_LOCK0_KICK0
&__TIFS_SEC_LOCK0_KICK0=(0x44230020)
LOCAL &__TIFS_SEC_LOCK0_KICK1
&__TIFS_SEC_LOCK0_KICK1=(0x44230024)
LOCAL &__SEC_HSM_RESET
&__SEC_HSM_RESET=(0x44230800)
// -- TIFS_SEC_MMR UNLOCK KEY
LOCAL &__HSM_KICK0_UNLOCK
&__HSM_KICK0_UNLOCK=(0xF457C023)
LOCAL &__HSM_KICK1_UNLOCK
&__HSM_KICK1_UNLOCK=(0x93B0A410)
LOCAL &__HSM_M4_IRAM_BASE_ADDRESS
&__HSM_M4_IRAM_BASE_ADDRESS=(0x43C00000)

GLOBAL &path_J7AEP_SI_cmm
&path_J7AEP_SI_cmm=OS.PPF()

IF "&function"=="DMSC_FLOW"
(
        &__DMSC_FLOW=(1.)
        &function=""
)
IF "&function"!=""
(
	GOSUB &function &args
)
ELSE
(
	GOSUB StartUp
        GOSUB __GeL_MeNu_CrEaTe
        GOSUB OnTargetConnect
)
ENDDO

StartUp:
(
	// -- Load the PLL GEL. 
	;DO ~~~~/J7AEP_PLL/J7AEP_PLL_MMR.cmm
	;DO ~~~~/J7AEP_PLL/J7AEP_PLL_PARAMS.cmm
	;DO ~~~~/J7AEP_PLL/J7AEP_PLL.cmm
	DO ~~~~/J7AEP_PLL/J7AEP_PLL_MMR_PARAMS_PLL.cmm

        DO ~~~~/J7AEP_PSC/J7AEP_PSC.cmm
	;DO ~~~~/J7AEP_DDR_SI/J7-DDR-addr-map-offs.cmm
	;DO ~~~~/J7AEP_DDR_SI/J721S2-DDR-EVM-LP4-2132.cmm
	;DO ~~~~/J7AEP_DDR_SI/J7_DDR_Config.cmm
	;;DO ~~~~/J7AEP_DDR_SI/J721S2_addr-map-offs-LP4-2132_DDR_config.cmm
        DO ~~~~/J7AEP_DDR_SI/J721S2_addr-map-offs-LP4-4266_DDR_config.cmm
        DO ~~~~/J7AEP_R5LOCKSTEP.cmm
	DO ~~~~/registerpoke.cmm
        DO ~~~~/J7AEP_PADCONFIG/J7AEP_PADCONFIG.cmm
        DO ~~~~/J7AEP_OBSCLK/J7AEP_OBSCLK.cmm
	RETURN
)

OnTargetConnect:
(
	GOSUB Configure_ATCM
	GOSUB Configure_RAT
	GOSUB Configure_R5F_Halt_Upon_PowerUp
	GOSUB Configure_C71_Halt_Upon_PowerUp
	DO "&path_J7AEP_PLL_MMR_PARAMS_PLL_cmm" Set_All_PLL
	ENTRY &__V4
	DO "&path_J7AEP_PSC_cmm" Set_PSC_All_On
	ENTRY &__V5
	IF (Var.VALUE(&__DMSC_FLOW)==0x0)
	(
                DO "&path_J721S2_addr_map_offs_LP4_4266_DDR_config_cmm" J7_LPDDR4_Config
                ;;DO "&path_J721S2_addr_map_offs_LP4_2132_DDR_config_cmm" J7_LPDDR4_Config
		ENTRY &__V9
	)
        RETURN
)
// --  ************************************************************************* 
// --  Global Helper Functions 
// --  ************************************************************************* 
// --  Read from an MMR. 

Read_MMR:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL unsigned int \mmr_address=&__VF0
	Var.NEWLOCAL unsigned int * \p_mmr
	Var.Assign \p_mmr=((unsigned int *)\mmr_address)
	&__FUNCTION_RETURN_VALUE=Var.Value(*\p_mmr)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)
// --  Write to an MMR. 

Write_MMR:
(
	PRIVATE &__VF0 &__VF1
	ENTRY &__VF0 &__VF1
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	
	Var.NEWLOCAL unsigned int \mmr_address=&__VF0
	Var.NEWLOCAL unsigned int \mmr_value=&__VF1
	Var.NEWLOCAL unsigned int * \p_mmr
	Var.Assign \p_mmr=((unsigned int *)\mmr_address)
	Data.Set D:(Var.VALUE(\p_mmr)) %Long Var.VALUE(\mmr_value)
	RETURN
)
// --  Write to a specific field in an MMR. 

Write_MMR_Field:
(
	PRIVATE &__VF0 &__VF1 &__VF2 &__VF3
	ENTRY &__VF0 &__VF1 &__VF2 &__VF3
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	&__VF2=&__VF2
	&__VF3=&__VF3
	
	Var.NEWLOCAL unsigned int \mmr_address=&__VF0
	Var.NEWLOCAL unsigned int \field_value=&__VF1
	Var.NEWLOCAL unsigned int \width=&__VF2
	Var.NEWLOCAL unsigned int \leftshift=&__VF3
	Var.NEWLOCAL unsigned int * \p_mmr
	Var.NEWLOCAL unsigned int \mask
	Var.Assign \p_mmr=((unsigned int *)\mmr_address)
	Var.Assign \mask=(((0x1<<(\width))-0x1)<<\leftshift)
	Var.Assign \mask=~\mask
	Var.Assign (*\p_mmr&=\mask)
	Var.Assign (*\p_mmr|=(\field_value<<\leftshift))
	RETURN
)
// --  Read from a specific field in an MMR. 

Read_MMR_Field:
(
	PRIVATE &__VF0 &__VF1 &__VF2
	ENTRY &__VF0 &__VF1 &__VF2
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	&__VF2=&__VF2
	
	Var.NEWLOCAL unsigned int \mmr_address=&__VF0
	Var.NEWLOCAL unsigned int \width=&__VF1
	Var.NEWLOCAL unsigned int \leftshift=&__VF2
	Var.NEWLOCAL unsigned int * \p_mmr
	Var.NEWLOCAL unsigned int \mask
	Var.NEWLOCAL unsigned int \retval
	Var.Assign \p_mmr=((unsigned int *)\mmr_address)
	Var.Assign \mask=(((0x1<<(\width))-0x1)<<\leftshift)
	Var.Assign \retval=((\Data_Long(\p_mmr)&\mask)>>\leftshift)
	&__FUNCTION_RETURN_VALUE=Var.VALUE(\retval)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)

Load_HSM_M4_WFI_Vector:
(
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	Var.Assign \address_offset=0x20000000
	Data.Set D:((((Var.VALUE(&__HSM_M4_IRAM_BASE_ADDRESS)+(Var.VALUE(\address_offset)))+0x0))) %Long Var.VALUE(0x00001000)
	Data.Set D:((((Var.VALUE(&__HSM_M4_IRAM_BASE_ADDRESS)+(Var.VALUE(\address_offset)))+0x4))) %Long (0x00000400+0x1)
	Data.Set D:((((Var.VALUE(&__HSM_M4_IRAM_BASE_ADDRESS)+(Var.VALUE(\address_offset)))+0x400))) %Long Var.VALUE(0xBF30BF30)
	PRINT "HSM_M4F WFI Vector set into IRAM."
	PRINT ""
	RETURN
)

__GeL_MeNu_CrEaTe:
(
	MENU.ReProgram
	(
		ADD
		MENU
		(
			POPUP "GEL"
			(
				POPUP "Initial Device Configuration"
				(
					MENUITEM "Configure_RAT" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_RAT
					)
					MENUITEM "Configure_ATCM" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_ATCM
					)
					MENUITEM "Configure_R5F_Bootvectors" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_R5F_Bootvectors
					)
					MENUITEM "Configure_R5F_Halt_Upon_PowerUp" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_R5F_Halt_Upon_PowerUp
					)
					MENUITEM "Configure_C71_Halt_Upon_PowerUp" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_C71_Halt_Upon_PowerUp
					)
					MENUITEM "Configure_C71_Bootvector" 
					(
						DO "&path_J7AEP_SI_cmm" Configure_C71_Bootvector
					)
					MENUITEM "Init_HSM_M4" 
					(
						DO "&path_J7AEP_SI_cmm" Init_HSM_M4
					)
				)
			)
		)
	)
	RETURN
)

Configure_RAT:
(
	Var.NEWLOCAL unsigned int \read_pid
	Var.Assign \read_pid=0x0
	Var.NEWLOCAL unsigned int \i0
	Var.Assign \i0=0x0
	Var.Assign \read_pid=\Data_Long((&__MAIN_PSC_BASE))
	PRINT "This GEL is currently only supported for use from the Cortex-M3 inside the DMSC."
	PRINT ""
	PRINT "Do not run this GEL from any other CPU on the SoC."
	PRINT ""
	PRINT "This script sets the first address translation region to [0x8000_0000, 0x0000_0000]."
	PRINT ""
	PRINT "It also sets the second address translation region to    [0x6000_0000, 0x4000_0000]."
	PRINT ""
	PRINT "This is consistent with the SoC DV assumptions."
	PRINT ""
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x24))) %Long Var.VALUE(0x80000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x28))) %Long Var.VALUE(0x00000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x2C))) %Long Var.VALUE(0x00000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x20))) %Long Var.VALUE(0x8000001D)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x44))) %Long Var.VALUE(0x60000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x48))) %Long Var.VALUE(0x40000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x4C))) %Long Var.VALUE(0x00000000)
	Data.Set D:(((Var.VALUE(&__CSL_WKUP_DMSC0_RAT_BASE)+0x40))) %Long Var.VALUE(0x8000001D)
        // used with M4-Flash-Burn
	Data.Set D:(((&__CSL_WKUP_DMSC0_RAT_BASE+0x34))) %Long Var.VALUE(0xD0000000)
	Data.Set D:(((&__CSL_WKUP_DMSC0_RAT_BASE+0x38))) %Long Var.VALUE(0x50000000)
	Data.Set D:(((&__CSL_WKUP_DMSC0_RAT_BASE+0x3C))) %Long Var.VALUE(0x00000000)
	Data.Set D:(((&__CSL_WKUP_DMSC0_RAT_BASE+0x30))) %Long Var.VALUE(0x8000001D)
        
	RETURN
	
)

Configure_ATCM:
(
	// -- Enable ATCM
	PRINT "Configuring ATCM for the R5Fs"
	PRINT ""
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x100))) %Long Var.VALUE(0x888)
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x180))) %Long Var.VALUE(0x888)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x100))) %Long Var.VALUE(0x888)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x180))) %Long Var.VALUE(0x888)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1100))) %Long Var.VALUE(0x888)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1180))) %Long Var.VALUE(0x888)
	PRINT "ATCM Configured."
	PRINT ""
	RETURN
	
)

Configure_R5F_Bootvectors:
(
	// -- Set bootvector (default 0x822000) to 0x0.
	PRINT "Configuring bootvectors"
	PRINT ""
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x110))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x114))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x190))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x194))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x110))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x114))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x190))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x194))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1110))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1114))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1190))) %Long Var.VALUE(0x0)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1194))) %Long Var.VALUE(0x0)
	PRINT "Bootvectors configured."
	PRINT ""
	RETURN
	
)

Configure_R5F_Halt_Upon_PowerUp:
(
	// -- Put all R5Fs in HALT mode upon PORz by writing to the MMRs.
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x120))) %Long Var.VALUE(0x1)
	Data.Set D:(((Var.VALUE(&__CSL_MCU_SEC_MMR0_CFG0_BASE)+0x1A0))) %Long Var.VALUE(0x1)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x120))) %Long Var.VALUE(0x1)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1A0))) %Long Var.VALUE(0x1)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x1120))) %Long Var.VALUE(0x1)
	Data.Set D:(((Var.VALUE(&__CSL_MAIN_SEC_MMR0_BOOT_CTRL_BASE)+0x11A0))) %Long Var.VALUE(0x1)
	PRINT "R5F Halt bits set."
	PRINT ""
	RETURN
	
)

Configure_C71_Halt_Upon_PowerUp:
(
	// -- Configure all C7x DSPs to wait in reset.
	Data.Set D:(((0x62060244))) %Long Var.VALUE(0x1)  ; Enable routing without FW
        Data.Set EDBG:0x400003f0 %Long 0x00190000         ; Unlock Power-AP unlocked
	;GOSUB GEL_EvalOnTarget "&__C71X_0" "&__GEL_SetWaitInResetMode(&__1)"
	PER.Set.simple EDBG:0x40000320 %Long 0x00224003
	;GOSUB GEL_EvalOnTarget "&__C71X_1" "&__GEL_SetWaitInResetMode(&__1)"
	PER.Set.simple EDBG:0x40000324 %Long 0x00224003
	PRINT "C71X_x DSPs configured for Wait In Reset Mode"
	PRINT ""
	RETURN
	
)

Configure_C71_Bootvector:
(
	Data.Set D:(((Var.VALUE(&__CSL_COMPUTE_CLUSTER0_DMSC_BOOT_BASE)+0x5008))) %Long (0x64801000/0x4)
	Data.Set D:(((Var.VALUE(&__CSL_COMPUTE_CLUSTER0_DMSC_BOOT_BASE)+0x6008))) %Long (0x64801000/0x4)
	PRINT "C71 Bootvectors configured."
	PRINT ""
	RETURN
	
)

Init_HSM_M4:
(
	PRINT "Initializing HSM_M4F ..."
	PRINT ""
	Data.Set D:(((Var.VALUE(&__TIFS_SEC_LOCK0_KICK0)))) %Long Var.VALUE(&__HSM_KICK0_UNLOCK)
	Data.Set D:(((Var.VALUE(&__TIFS_SEC_LOCK0_KICK1)))) %Long Var.VALUE(&__HSM_KICK1_UNLOCK)
	Data.Set D:(((Var.VALUE(&__SEC_HSM_RESET)))) %Long Var.VALUE(0x1)
	DO "&path_J7AEP_PSC_cmm" change_HSM_M4_LRST 0x1
	ENTRY &__V8
	GOSUB Load_HSM_M4_WFI_Vector
	DO "&path_J7AEP_PSC_cmm" change_HSM_M4_LRST 0x0
	ENTRY &__V10
	PRINT "HSM_M4F Initialized."
	PRINT ""
	RETURN
	
)
