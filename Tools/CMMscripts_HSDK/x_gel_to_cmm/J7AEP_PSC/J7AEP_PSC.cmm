LOCAL &function &args
ENTRY &function %LINE &args
// --  Copyright (c) 2020, Texas Instruments Incorporated
// --  * All rights reserved.
// --  *
// --  * Redistribution and use in source and binary forms, with or without
// --  * modification, are permitted provided that the following conditions
// --  * are met:
// --  *
// --  * *  Redistributions of source code must retain the above copyright
// --  *    notice, this list of conditions and the following disclaimer.
// --  *
// --  * *  Redistributions in binary form must reproduce the above copyright
// --  *    notice, this list of conditions and the following disclaimer in the
// --  *    documentation and/or other materials provided with the distribution.
// --  *
// --  * *  Neither the name of Texas Instruments Incorporated nor the names of
// --  *    its contributors may be used to endorse or promote products derived
// --  *    from this software without specific prior written permission.
// --  *
// --  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// --  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// --  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// --  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// --  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// --  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// --  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// --  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// --  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// --  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// --  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// --  * macro definitions for the WKUP_PSC
// -- PD indexes
LOCAL &__PD_GP_CORE_CTL_WKUP
&__PD_GP_CORE_CTL_WKUP=0.
LOCAL &__PD_MCU_PULSAR
&__PD_MCU_PULSAR=1.
// -- LPSC indexes
LOCAL &__LPSC_WKUP_ALWAYSON
&__LPSC_WKUP_ALWAYSON=0.
LOCAL &__LPSC_DMSC
&__LPSC_DMSC=1.
// -- For M3 reset control only.
LOCAL &__LPSC_DEBUG2DMSC
&__LPSC_DEBUG2DMSC=2.
LOCAL &__LPSC_WKUP_GPIO
&__LPSC_WKUP_GPIO=3.
// -- For clock gating purposes only. Always on.
LOCAL &__LPSC_WKUPMCU2MAIN
&__LPSC_WKUPMCU2MAIN=4.
LOCAL &__LPSC_MAIN2WKUPMCU
&__LPSC_MAIN2WKUPMCU=5.
LOCAL &__LPSC_MCU_TEST
&__LPSC_MCU_TEST=6.
LOCAL &__LPSC_MCU_DEBUG
&__LPSC_MCU_DEBUG=7.
LOCAL &__LPSC_MCU_MCAN_0
&__LPSC_MCU_MCAN_0=8.
LOCAL &__LPSC_MCU_MCAN_1
&__LPSC_MCU_MCAN_1=9.
LOCAL &__LPSC_MCU_OSPI_0
&__LPSC_MCU_OSPI_0=10.
LOCAL &__LPSC_MCU_OSPI_1
&__LPSC_MCU_OSPI_1=11.
LOCAL &__LPSC_MCU_HYPERBUS
&__LPSC_MCU_HYPERBUS=12.
LOCAL &__LPSC_MCU_I3C_0
&__LPSC_MCU_I3C_0=13.
LOCAL &__LPSC_MCU_I3C_1
&__LPSC_MCU_I3C_1=14.
LOCAL &__LPSC_MCU_ADC_0
&__LPSC_MCU_ADC_0=15.
LOCAL &__LPSC_MCU_ADC_1
&__LPSC_MCU_ADC_1=16.
LOCAL &__LPSC_WKUP_SPARE_0
&__LPSC_WKUP_SPARE_0=17.
LOCAL &__LPSC_WKUP_SPARE_1
&__LPSC_WKUP_SPARE_1=18.
LOCAL &__LPSC_MCU_R5_0
&__LPSC_MCU_R5_0=19.
// -- PD_MCU_PULSAR
LOCAL &__LPSC_MCU_R5_1
&__LPSC_MCU_R5_1=20.
// -- PD_MCU_PULSAR
LOCAL &__LPSC_MCU_PULSAR_PBIST_0
&__LPSC_MCU_PULSAR_PBIST_0=21.
// -- PD_MCU_PULSAR
// -- WKUP CTRL MMRs --> controls WKUP analog stuff
// -- MCU CTRL MMRs --> controls MCU PSRAM
// -- MCU PLL MMRs --> controls MCU PLL programming interfaces
// -- WKUP PLL Controller --> runs to wkup efuse chain storage
// --  * macro definitions for the MAIN_PSC
// -- PD indexes
LOCAL &__PD_GP_CORE_CTRL
&__PD_GP_CORE_CTRL=0.
LOCAL &__PD_MCANSS
&__PD_MCANSS=1.
LOCAL &__PD_DSS
&__PD_DSS=2.
LOCAL &__PD_ICSS
&__PD_ICSS=3.
LOCAL &__PD_9GSS
&__PD_9GSS=4.
LOCAL &__PD_SERDES_0
&__PD_SERDES_0=5.
LOCAL &__PD_SERDES_1
&__PD_SERDES_1=6.
LOCAL &__PD_SERDES_2
&__PD_SERDES_2=7.
LOCAL &__PD_SERDES_3
&__PD_SERDES_3=8.
LOCAL &__PD_SERDES_4
&__PD_SERDES_4=9.
LOCAL &__PD_SERDES_5
&__PD_SERDES_5=10.
LOCAL &__PD_TIMER
&__PD_TIMER=11.
LOCAL &__PD_C71X_0
&__PD_C71X_0=12.
LOCAL &__PD_C71X_1
&__PD_C71X_1=13.
LOCAL &__PD_A72_CLUSTER_0
&__PD_A72_CLUSTER_0=14.
LOCAL &__PD_A72_0
&__PD_A72_0=15.
LOCAL &__PD_A72_1
&__PD_A72_1=16.
LOCAL &__PD_A72_CLUSTER_1
&__PD_A72_CLUSTER_1=17.
LOCAL &__PD_A72_2
&__PD_A72_2=18.
LOCAL &__PD_A72_3
&__PD_A72_3=19.
LOCAL &__PD_GPUCOM
&__PD_GPUCOM=20.
LOCAL &__PD_GPUCORE
&__PD_GPUCORE=21.
LOCAL &__PD_C66X_0
&__PD_C66X_0=22.
LOCAL &__PD_C66X_1
&__PD_C66X_1=23.
LOCAL &__PD_PULSAR_0
&__PD_PULSAR_0=24.
LOCAL &__PD_PULSAR_1
&__PD_PULSAR_1=25.
LOCAL &__PD_DECODE
&__PD_DECODE=26.
LOCAL &__PD_ENCODE
&__PD_ENCODE=27.
LOCAL &__PD_DMPAC
&__PD_DMPAC=28.
LOCAL &__PD_VPAC
&__PD_VPAC=29.
LOCAL &__PD_A72_CL0_2
&__PD_A72_CL0_2=30.
LOCAL &__PD_A72_CL0_3
&__PD_A72_CL0_3=31.
LOCAL &__PD_A72_CL1_2
&__PD_A72_CL1_2=32.
LOCAL &__PD_A72_CL1_3
&__PD_A72_CL1_3=33.
LOCAL &__PD_VPAC_1
&__PD_VPAC_1=34.
LOCAL &__PD_ENCODE_1
&__PD_ENCODE_1=35.
LOCAL &__PD_DSI_1
&__PD_DSI_1=36.
LOCAL &__PD_CPSW_2
&__PD_CPSW_2=37.
LOCAL &__PD_DDR2
&__PD_DDR2=38.
LOCAL &__PD_PULSAR_2
&__PD_PULSAR_2=39.
LOCAL &__PD_SPARE4
&__PD_SPARE4=40.
LOCAL &__PD_SPARE5
&__PD_SPARE5=41.
LOCAL &__PD_SPARE6
&__PD_SPARE6=42.
// -- LPSC indexes
LOCAL &__LPSC_MAIN_ALWAYSON
&__LPSC_MAIN_ALWAYSON=0.
LOCAL &__LPSC_MAIN_TEST
&__LPSC_MAIN_TEST=1.
LOCAL &__LPSC_MAIN_PBIST
&__LPSC_MAIN_PBIST=2.
LOCAL &__LPSC_PER_AUDIO
&__LPSC_PER_AUDIO=3.
LOCAL &__LPSC_PER_ATL
&__LPSC_PER_ATL=4.
LOCAL &__LPSC_PER_MLB
&__LPSC_PER_MLB=5.
LOCAL &__LPSC_PER_MOTOR
&__LPSC_PER_MOTOR=6.
LOCAL &__LPSC_PER_MISCIO
&__LPSC_PER_MISCIO=7.
LOCAL &__LPSC_PER_GPMC
&__LPSC_PER_GPMC=8.
LOCAL &__LPSC_PER_VPFE
&__LPSC_PER_VPFE=9.
LOCAL &__LPSC_PER_VPE
&__LPSC_PER_VPE=10.
LOCAL &__LPSC_PER_SPARE_0
&__LPSC_PER_SPARE_0=11.
LOCAL &__LPSC_PER_SPARE_1
&__LPSC_PER_SPARE_1=12.
LOCAL &__LPSC_MAIN_DEBUG
&__LPSC_MAIN_DEBUG=13.
LOCAL &__LPSC_EMIF_DATA_0
&__LPSC_EMIF_DATA_0=14.
LOCAL &__LPSC_EMIF_CFG_0
&__LPSC_EMIF_CFG_0=15.
LOCAL &__LPSC_EMIF_DATA_1
&__LPSC_EMIF_DATA_1=16.
LOCAL &__LPSC_EMIF_CFG_1
&__LPSC_EMIF_CFG_1=17.
LOCAL &__LPSC_PER_SPARE_2
&__LPSC_PER_SPARE_2=18.
LOCAL &__LPSC_CC_TOP_PBIST
&__LPSC_CC_TOP_PBIST=19.
LOCAL &__LPSC_USB_0
&__LPSC_USB_0=20.
LOCAL &__LPSC_USB_1
&__LPSC_USB_1=21.
LOCAL &__LPSC_USB_2
&__LPSC_USB_2=22.
LOCAL &__LPSC_MMC4B_0
&__LPSC_MMC4B_0=23.
LOCAL &__LPSC_MMC4B_1
&__LPSC_MMC4B_1=24.
LOCAL &__LPSC_MMC8B_0
&__LPSC_MMC8B_0=25.
LOCAL &__LPSC_UFS_0
&__LPSC_UFS_0=26.
LOCAL &__LPSC_UFS_1
&__LPSC_UFS_1=27.
LOCAL &__LPSC_PCIE_0
&__LPSC_PCIE_0=28.
LOCAL &__LPSC_PCIE_1
&__LPSC_PCIE_1=29.
LOCAL &__LPSC_PCIE_2
&__LPSC_PCIE_2=30.
LOCAL &__LPSC_PCIE_3
&__LPSC_PCIE_3=31.
LOCAL &__LPSC_SAUL
&__LPSC_SAUL=32.
LOCAL &__LPSC_PER_I3C
&__LPSC_PER_I3C=33.
LOCAL &__LPSC_MAIN_MCANSS_0
&__LPSC_MAIN_MCANSS_0=34.
LOCAL &__LPSC_MAIN_MCANSS_1
&__LPSC_MAIN_MCANSS_1=35.
LOCAL &__LPSC_MAIN_MCANSS_2
&__LPSC_MAIN_MCANSS_2=36.
LOCAL &__LPSC_MAIN_MCANSS_3
&__LPSC_MAIN_MCANSS_3=37.
LOCAL &__LPSC_MAIN_MCANSS_4
&__LPSC_MAIN_MCANSS_4=38.
LOCAL &__LPSC_MAIN_MCANSS_5
&__LPSC_MAIN_MCANSS_5=39.
LOCAL &__LPSC_MAIN_MCANSS_6
&__LPSC_MAIN_MCANSS_6=40.
LOCAL &__LPSC_MAIN_MCANSS_7
&__LPSC_MAIN_MCANSS_7=41.
LOCAL &__LPSC_MAIN_MCANSS_8
&__LPSC_MAIN_MCANSS_8=42.
LOCAL &__LPSC_MAIN_MCANSS_9
&__LPSC_MAIN_MCANSS_9=43.
LOCAL &__LPSC_MAIN_MCANSS_10
&__LPSC_MAIN_MCANSS_10=44.
LOCAL &__LPSC_MAIN_MCANSS_11
&__LPSC_MAIN_MCANSS_11=45.
LOCAL &__LPSC_MAIN_MCANSS_12
&__LPSC_MAIN_MCANSS_12=46.
LOCAL &__LPSC_MAIN_MCANSS_13
&__LPSC_MAIN_MCANSS_13=47.
LOCAL &__LPSC_DSS
&__LPSC_DSS=48.
LOCAL &__LPSC_DSS_PBIST
&__LPSC_DSS_PBIST=49.
LOCAL &__LPSC_DSI
&__LPSC_DSI=50.
LOCAL &__LPSC_EDP_0
&__LPSC_EDP_0=51.
LOCAL &__LPSC_EDP_1
&__LPSC_EDP_1=52.
LOCAL &__LPSC_CSIRX_0
&__LPSC_CSIRX_0=53.
LOCAL &__LPSC_CSIRX_1
&__LPSC_CSIRX_1=54.
LOCAL &__LPSC_CSIRX_2
&__LPSC_CSIRX_2=55.
LOCAL &__LPSC_CSITX_0
&__LPSC_CSITX_0=56.
LOCAL &__LPSC_TX_DPHY_0
&__LPSC_TX_DPHY_0=57.
LOCAL &__LPSC_CSIRX_PHY_0
&__LPSC_CSIRX_PHY_0=58.
LOCAL &__LPSC_CSIRX_PHY_1
&__LPSC_CSIRX_PHY_1=59.
LOCAL &__LPSC_CSIRX_PHY_2
&__LPSC_CSIRX_PHY_2=60.
LOCAL &__LPSC_ICSSG_0
&__LPSC_ICSSG_0=61.
LOCAL &__LPSC_ICSSG_1
&__LPSC_ICSSG_1=62.
LOCAL &__LPSC_9GSS
&__LPSC_9GSS=63.
LOCAL &__LPSC_SERDES_0
&__LPSC_SERDES_0=64.
LOCAL &__LPSC_SERDES_1
&__LPSC_SERDES_1=65.
LOCAL &__LPSC_SERDES_2
&__LPSC_SERDES_2=66.
LOCAL &__LPSC_SERDES_3
&__LPSC_SERDES_3=67.
LOCAL &__LPSC_SERDES_4
&__LPSC_SERDES_4=68.
LOCAL &__LPSC_SERDES_5
&__LPSC_SERDES_5=69.
LOCAL &__LPSC_DMTIMER_0
&__LPSC_DMTIMER_0=70.
LOCAL &__LPSC_DMTIMER_1
&__LPSC_DMTIMER_1=71.
LOCAL &__LPSC_DMTIMER_2
&__LPSC_DMTIMER_2=72.
LOCAL &__LPSC_DMTIMER_3
&__LPSC_DMTIMER_3=73.
LOCAL &__LPSC_C71X_0
&__LPSC_C71X_0=74.
LOCAL &__LPSC_C71X_0_PBIST
&__LPSC_C71X_0_PBIST=75.
LOCAL &__LPSC_C71X_1
&__LPSC_C71X_1=76.
LOCAL &__LPSC_C71X_1_PBIST
&__LPSC_C71X_1_PBIST=77.
LOCAL &__LPSC_A72_CLUSTER_0
&__LPSC_A72_CLUSTER_0=78.
LOCAL &__LPSC_A72_CLUSTER_0_PBIST
&__LPSC_A72_CLUSTER_0_PBIST=79.
LOCAL &__LPSC_A72_0
&__LPSC_A72_0=80.
LOCAL &__LPSC_A72_1
&__LPSC_A72_1=81.
LOCAL &__LPSC_A72_CLUSTER_1
&__LPSC_A72_CLUSTER_1=82.
LOCAL &__LPSC_A72_CLUSTER_1_PBIST
&__LPSC_A72_CLUSTER_1_PBIST=83.
LOCAL &__LPSC_A72_2
&__LPSC_A72_2=84.
LOCAL &__LPSC_A72_3
&__LPSC_A72_3=85.
LOCAL &__LPSC_GPUCOM
&__LPSC_GPUCOM=86.
LOCAL &__LPSC_GPUPBIST
&__LPSC_GPUPBIST=87.
LOCAL &__LPSC_GPUCORE
&__LPSC_GPUCORE=88.
LOCAL &__LPSC_C66X_0
&__LPSC_C66X_0=89.
LOCAL &__LPSC_C66X_PBIST_0
&__LPSC_C66X_PBIST_0=90.
LOCAL &__LPSC_C66X_1
&__LPSC_C66X_1=91.
LOCAL &__LPSC_C66X_PBIST_1
&__LPSC_C66X_PBIST_1=92.
LOCAL &__LPSC_PULSAR_0_R5_0
&__LPSC_PULSAR_0_R5_0=93.
LOCAL &__LPSC_PULSAR_0_R5_1
&__LPSC_PULSAR_0_R5_1=94.
LOCAL &__LPSC_PULSAR_0_PBIST
&__LPSC_PULSAR_0_PBIST=95.
LOCAL &__LPSC_PULSAR_1_R5_0
&__LPSC_PULSAR_1_R5_0=96.
LOCAL &__LPSC_PULSAR_1_R5_1
&__LPSC_PULSAR_1_R5_1=97.
LOCAL &__LPSC_PULSAR_1_PBIST
&__LPSC_PULSAR_1_PBIST=98.
LOCAL &__LPSC_DECODE_0
&__LPSC_DECODE_0=99.
LOCAL &__LPSC_DECODE_PBIST
&__LPSC_DECODE_PBIST=100.
LOCAL &__LPSC_ENCODE_0
&__LPSC_ENCODE_0=101.
LOCAL &__LPSC_ENCODE_PBIST
&__LPSC_ENCODE_PBIST=102.
LOCAL &__LPSC_DMPAC
&__LPSC_DMPAC=103.
LOCAL &__LPSC_SDE
&__LPSC_SDE=104.
LOCAL &__LPSC_DMPAC_PBIST
&__LPSC_DMPAC_PBIST=105.
LOCAL &__LPSC_VPAC
&__LPSC_VPAC=106.
LOCAL &__LPSC_VPAC_PBIST
&__LPSC_VPAC_PBIST=107.
LOCAL &__LPSC_A72_CLUSTER0_CORE2
&__LPSC_A72_CLUSTER0_CORE2=108.
LOCAL &__LPSC_A72_CLUSTER0_CORE3
&__LPSC_A72_CLUSTER0_CORE3=109.
LOCAL &__LPSC_A72_CLUSTER1_CORE2
&__LPSC_A72_CLUSTER1_CORE2=110.
LOCAL &__LPSC_A72_CLUSTER1_CORE3
&__LPSC_A72_CLUSTER1_CORE3=111.
LOCAL &__LPSC_VPAC1
&__LPSC_VPAC1=112.
LOCAL &__LPSC_VPAC1_PBIST
&__LPSC_VPAC1_PBIST=113.
LOCAL &__LPSC_ENCODE_1
&__LPSC_ENCODE_1=114.
LOCAL &__LPSC_ENCODE_1_PBIST
&__LPSC_ENCODE_1_PBIST=115.
LOCAL &__LPSC_CSITX_1
&__LPSC_CSITX_1=116.
LOCAL &__LPSC_TX_DPHY_1
&__LPSC_TX_DPHY_1=117.
LOCAL &__LPSC_DSI_1_PBIST
&__LPSC_DSI_1_PBIST=118.
LOCAL &__LPSC_CPSW_2
&__LPSC_CPSW_2=119.
LOCAL &__LPSC_EMIF_DATA_2
&__LPSC_EMIF_DATA_2=120.
LOCAL &__LPSC_EMIF_CFG_2
&__LPSC_EMIF_CFG_2=121.
LOCAL &__LPSC_PULSAR_2_R5_0
&__LPSC_PULSAR_2_R5_0=122.
LOCAL &__LPSC_PULSAR_2_R5_1
&__LPSC_PULSAR_2_R5_1=123.
LOCAL &__LPSC_PULSAR_2_PBIST
&__LPSC_PULSAR_2_PBIST=124.
LOCAL &__LPSC_SPARE_4
&__LPSC_SPARE_4=125.
LOCAL &__LPSC_SPARE_5
&__LPSC_SPARE_5=126.
LOCAL &__LPSC_SPARE_6
&__LPSC_SPARE_6=127.
// -- Main CTRL MMRs --> not controlled by Main PSC
// -- Main PLL CTRL --> not controlled by Main PSC
// -- Main PLL MMRs --> not controlled by Main PSC
// -- common base addresses
LOCAL &__WAKEUP_PSC_BASE
&__WAKEUP_PSC_BASE=(0x42000000)
LOCAL &__MAIN_PSC_BASE
&__MAIN_PSC_BASE=(0x00400000)
LOCAL &__PSC_PID
&__PSC_PID=(0x44827A00)
LOCAL &__M3_SOC_OFFSET
&__M3_SOC_OFFSET=(0x60000000)
LOCAL &__M3_RAT_CTRL
&__M3_RAT_CTRL=(0x44200020)
// -- Base address + CTRL register offset.
// -- Defines for WKUP and MAIN PSC indices
LOCAL &__MAIN_PSC_INDEX
&__MAIN_PSC_INDEX=0.
LOCAL &__WAKEUP_PSC_INDEX
&__WAKEUP_PSC_INDEX=1.
// -- PSC MMR interface
LOCAL &__PSC_MDCTL00
&__PSC_MDCTL00=(0xA00)
LOCAL &__PSC_MDSTAT00
&__PSC_MDSTAT00=(0x800)
LOCAL &__PSC_PDCTL00
&__PSC_PDCTL00=(0x300)
LOCAL &__PSC_PDSTAT00
&__PSC_PDSTAT00=(0x200)
LOCAL &__PSC_PTCMD
&__PSC_PTCMD=(0x120)
LOCAL &__PSC_PTSTAT
&__PSC_PTSTAT=(0x128)
LOCAL &__PSC_PTCMD_H
&__PSC_PTCMD_H=(0x124)
LOCAL &__PSC_PTSTAT_H
&__PSC_PTSTAT_H=(0x12C)
// -- PSC Parameter definitions
LOCAL &__PSC_PD_OFF
&__PSC_PD_OFF=(0x0)
LOCAL &__PSC_PD_ON
&__PSC_PD_ON=(0x1)
LOCAL &__PSC_SYNCRESETDISABLE
&__PSC_SYNCRESETDISABLE=(0x0)
LOCAL &__PSC_SYNCRESET
&__PSC_SYNCRESET=(0x1)
LOCAL &__PSC_DISABLE
&__PSC_DISABLE=(0x2)
LOCAL &__PSC_ENABLE
&__PSC_ENABLE=(0x3)
LOCAL &__PSC_TIMEOUT
&__PSC_TIMEOUT=(100.)
// -- PSC Register pre-calculations
LOCAL &__WAKEUP_PSC_MDCTL_BASE
&__WAKEUP_PSC_MDCTL_BASE=&__WAKEUP_PSC_BASE+&__PSC_MDCTL00
LOCAL &__WAKEUP_PSC_MDSTAT_BASE
&__WAKEUP_PSC_MDSTAT_BASE=&__WAKEUP_PSC_BASE+&__PSC_MDSTAT00
LOCAL &__WAKEUP_PSC_PDCTL_BASE
&__WAKEUP_PSC_PDCTL_BASE=&__WAKEUP_PSC_BASE+&__PSC_PDCTL00
LOCAL &__WAKEUP_PSC_PDSTAT_BASE
&__WAKEUP_PSC_PDSTAT_BASE=&__WAKEUP_PSC_BASE+&__PSC_PDSTAT00
LOCAL &__WAKEUP_PSC_PTCMD_BASE
&__WAKEUP_PSC_PTCMD_BASE=&__WAKEUP_PSC_BASE+&__PSC_PTCMD
LOCAL &__WAKEUP_PSC_PTSTAT_BASE
&__WAKEUP_PSC_PTSTAT_BASE=&__WAKEUP_PSC_BASE+&__PSC_PTSTAT
LOCAL &__WAKEUP_PSC_PTCMD
&__WAKEUP_PSC_PTCMD=&__WAKEUP_PSC_PTCMD_BASE
LOCAL &__WAKEUP_PSC_PTSTAT
&__WAKEUP_PSC_PTSTAT=&__WAKEUP_PSC_PTSTAT_BASE
LOCAL &__MAIN_PSC_MDCTL_BASE
&__MAIN_PSC_MDCTL_BASE=&__MAIN_PSC_BASE+&__PSC_MDCTL00
LOCAL &__MAIN_PSC_MDSTAT_BASE
&__MAIN_PSC_MDSTAT_BASE=&__MAIN_PSC_BASE+&__PSC_MDSTAT00
LOCAL &__MAIN_PSC_PDCTL_BASE
&__MAIN_PSC_PDCTL_BASE=&__MAIN_PSC_BASE+&__PSC_PDCTL00
LOCAL &__MAIN_PSC_PDSTAT_BASE
&__MAIN_PSC_PDSTAT_BASE=&__MAIN_PSC_BASE+&__PSC_PDSTAT00
LOCAL &__MAIN_PSC_PTCMD_BASE
&__MAIN_PSC_PTCMD_BASE=&__MAIN_PSC_BASE+&__PSC_PTCMD
LOCAL &__MAIN_PSC_PTSTAT_BASE
&__MAIN_PSC_PTSTAT_BASE=&__MAIN_PSC_BASE+&__PSC_PTSTAT
LOCAL &__MAIN_PSC_PTCMD
&__MAIN_PSC_PTCMD=&__MAIN_PSC_PTCMD_BASE
LOCAL &__MAIN_PSC_PTSTAT
&__MAIN_PSC_PTSTAT=&__MAIN_PSC_PTSTAT_BASE
LOCAL &__MAIN_PSC_PTCMD_H
&__MAIN_PSC_PTCMD_H=&__MAIN_PSC_BASE+&__PSC_PTCMD_H
LOCAL &__MAIN_PSC_PTSTAT_H
&__MAIN_PSC_PTSTAT_H=&__MAIN_PSC_BASE+&__PSC_PTSTAT_H

GLOBAL &path_J7AEP_PSC_cmm
&path_J7AEP_PSC_cmm=OS.PPF()
IF "&function"!=""
(
	GOSUB &function &args
)
ELSE
(
	GOSUB __GeL_MeNu_CrEaTe
)
ENDDO
// -- *****************************************************************************
// --  *
// --  * NAME:
// --  *      Set_MAIN_PSC_State
// --  *
// --  * PURPOSE:
// --  *      Set a new power state for the specified power domain pd_id and module 
// --  *		domain md_id. Wait for the power transition to complete.
// --  *
// --  * USAGE:
// --  *      This routine can be called as:
// --  *
// --  *      Set_MAIN_PSC_State(unsigned int pd_id, unsigned int md_id, unsigned int pd_state, unsigned int md_state)
// --  *
// --  *      pd_id - (i) power domain id
// --  *
// --  *      md_id - (i) module domain id
// --  *
// --  *		pd_state - (i) new power domain state value to set
// --  *					0 = PSC_PD_OFF
// --  *					1 = PSC_PD_ON
// --  *
// --  *      md_state - (i) new module domain state value to set
// --  *                  0 = PSC_SYNCRESETDISABLE (IP reset asserted and clock gated)
// --  *                  1 = PSC_SYNCRESET (IP reset asserted and clock running)
// --  *                  2 = PSC_DISABLE (IP reset released and clock gated, MMRs retained)
// --  *                  3 = PSC_ENABLE (IP reset released and clock running)
// --  * 
// --  * RETURN VALUE:
// --  *      0 if ok, !=0 for error
// --  *
// --  * REFERENCE:
// --  *
// --  ****************************************************************************

Set_MAIN_PSC_State:
(
	PRIVATE &__VF0 &__VF1 &__VF2 &__VF3
	ENTRY &__VF0 &__VF1 &__VF2 &__VF3
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	&__VF2=&__VF2
	&__VF3=&__VF3
	
	Var.NEWLOCAL unsigned int \pd_id=&__VF0
	Var.NEWLOCAL unsigned int \md_id=&__VF1
	Var.NEWLOCAL unsigned int \pd_state=&__VF2
	Var.NEWLOCAL unsigned int \md_state=&__VF3
	Var.NEWLOCAL unsigned int * \mdctl
	Var.NEWLOCAL unsigned int * \mdstat
	Var.NEWLOCAL unsigned int * \pdctl
	Var.NEWLOCAL unsigned int * \pdstat
	Var.NEWLOCAL unsigned int * \ptcmd
	Var.NEWLOCAL unsigned int * \ptstat
	Var.NEWLOCAL unsigned int \loop_cnt
	Var.Assign \loop_cnt=0x0
	Var.NEWLOCAL unsigned int \ret
	Var.Assign \ret=0x1
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	IF (Data.Long(D:(&__MAIN_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	// -- Added for support beyond 32-domains
	Var.IF ((\pd_id)>0x1F)
	(
		Var.Assign \ptcmd=&__MAIN_PSC_PTCMD_H
		Var.Assign \ptstat=&__MAIN_PSC_PTSTAT_H
	)
	ELSE
	(
		Var.Assign \ptcmd=&__MAIN_PSC_PTCMD
		Var.Assign \ptstat=&__MAIN_PSC_PTSTAT
	)
	Var.Assign \mdctl=((unsigned int *)((&__MAIN_PSC_MDCTL_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \mdstat=((unsigned int *)((&__MAIN_PSC_MDSTAT_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \pdctl=((unsigned int *)((&__MAIN_PSC_PDCTL_BASE+(0x4*(\pd_id)))+\address_offset))
	Var.Assign \pdstat=((unsigned int *)((&__MAIN_PSC_PDSTAT_BASE+(0x4*(\pd_id)))+\address_offset))
	IF (((Data.Long(D:Var.VALUE(\pdstat))&0x1)==Var.VALUE(\pd_state))&&((Data.Long(D:Var.VALUE(\mdstat))&0x1F)==Var.VALUE(\md_state)))
	(
		PRINT "No change needed."
		PRINT ""
		Var.Assign \ret=0x1
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Wait for GOSTAT to clear
	WHILE ((Var.VALUE(\loop_cnt)<&__PSC_TIMEOUT)&&((Data.Long(D:((Var.VALUE(\ptstat)+Var.VALUE(\address_offset))))&(0x1<<(Var.VALUE(\pd_id)%0x20)))!=0x0))
	(
		Var.Assign \loop_cnt=\loop_cnt+1
	)
	// -- For debugging
	// -- GEL_TextOut("GOSTAT clear wait 1st time\n");
	// --  Check if we got timeout error while waiting
	Var.IF ((\loop_cnt)>=&__PSC_TIMEOUT)
	(
		PRINT "Timeout Error. State not changed."
		PRINT ""
		Var.Assign \ret=0x0
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Set PDCTL NEXT to new state
	Data.Set D:(Var.VALUE(\pdctl)) %Long ((Data.Long(D:Var.VALUE(\pdctl))&(~0x1))|Var.VALUE(\pd_state))
	Data.Set D:(Var.VALUE(\mdctl)) %Long ((Data.Long(D:Var.VALUE(\mdctl))&(~0x1F))|Var.VALUE(\md_state))
	Data.Set D:(((Var.VALUE(\ptcmd)+Var.VALUE(\address_offset)))) %Long (Data.Long(D:((Var.VALUE(\ptcmd)+Var.VALUE(\address_offset))))|(0x1<<(Var.VALUE(\pd_id)%0x20)))
	Var.Assign \loop_cnt=0x0
	WHILE ((Var.VALUE(\loop_cnt)<&__PSC_TIMEOUT)&&((Data.Long(D:((Var.VALUE(\ptstat)+Var.VALUE(\address_offset))))&(0x1<<(Var.VALUE(\pd_id)%0x20)))!=0x0))
	(
		Var.Assign \loop_cnt=\loop_cnt+1
	)
	// -- For debugging
	// -- GEL_TextOut("GOSTAT clear wait 2nd time\n");
	// --  Check if we got timeout error while waiting
	Var.IF ((\loop_cnt)>=&__PSC_TIMEOUT)
	(
		PRINT "Timeout Error. State not changed."
		PRINT ""
		Var.Assign \ret=0x0
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Verify power domain and module domain state got changed
	IF (((Data.Long(D:Var.VALUE(\pdstat))&0x1)==Var.VALUE(\pd_state))&&((Data.Long(D:Var.VALUE(\mdstat))&0x1F)==Var.VALUE(\md_state)))
	(
		PRINT "Power domain and module state changed successfully."
		PRINT ""
		Var.Assign \ret=0x1
	)
	IF ((Data.Long(D:Var.VALUE(\pdstat))&0x1)!=Var.VALUE(\pd_state))
	(
		PRINT "ERROR: PSC power domain state NOT changed!"
		PRINT ""
		Var.Assign \ret=0x0
	)
	IF ((Data.Long(D:Var.VALUE(\mdstat))&0x1F)!=Var.VALUE(\md_state))
	(
		PRINT "ERROR: module state NOT changed!"
		PRINT ""
		Var.Assign \ret=0x0
	)
	&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)
// -- *****************************************************************************
// --  *
// --  * NAME:
// --  *      Set_WKUP_PSC_State
// --  *
// --  * PURPOSE:
// --  *      Set a new power state for the specified power domain pd_id and module 
// --  *		domain md_id. Wait for the power transition to complete.
// --  *
// --  * USAGE:
// --  *      This routine can be called as:
// --  *
// --  *      Set_WKUP_PSC_State(unsigned int pd_id, unsigned int md_id, unsigned int pd_state, unsigned int md_state)
// --  *
// --  *      pd_id - (i) power domain id
// --  *
// --  *      md_id - (i) module domain id
// --  *
// --  *		pd_state - (i) new power domain state value to set
// --  *					0 = PSC_PD_OFF
// --  *					1 = PSC_PD_ON
// --  *
// --  *      md_state - (i) new module domain state value to set
// --  *                  0 = PSC_SYNCRESETDISABLE (IP reset asserted and clock gated)
// --  *                  1 = PSC_SYNCRESET (IP reset asserted and clock running)
// --  *                  2 = PSC_DISABLE (IP reset released and clock gated, MMRs retained)
// --  *                  3 = PSC_ENABLE (IP reset released and clock running)
// --  * 
// --  * RETURN VALUE:
// --  *      0 if ok, !=0 for error
// --  *
// --  * REFERENCE:
// --  *
// --  ****************************************************************************

Set_WKUP_PSC_State:
(
	PRIVATE &__VF0 &__VF1 &__VF2 &__VF3
	ENTRY &__VF0 &__VF1 &__VF2 &__VF3
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	&__VF2=&__VF2
	&__VF3=&__VF3
	
	Var.NEWLOCAL unsigned int \pd_id=&__VF0
	Var.NEWLOCAL unsigned int \md_id=&__VF1
	Var.NEWLOCAL unsigned int \pd_state=&__VF2
	Var.NEWLOCAL unsigned int \md_state=&__VF3
	Var.NEWLOCAL unsigned int * \mdctl
	Var.NEWLOCAL unsigned int * \mdstat
	Var.NEWLOCAL unsigned int * \pdctl
	Var.NEWLOCAL unsigned int * \pdstat
	Var.NEWLOCAL unsigned int \loop_cnt
	Var.Assign \loop_cnt=0x0
	Var.NEWLOCAL unsigned int \ret
	Var.Assign \ret=0x1
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	Var.Assign \mdctl=((unsigned int *)((&__WAKEUP_PSC_MDCTL_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \mdstat=((unsigned int *)((&__WAKEUP_PSC_MDSTAT_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \pdctl=((unsigned int *)((&__WAKEUP_PSC_PDCTL_BASE+(0x4*(\pd_id)))+\address_offset))
	Var.Assign \pdstat=((unsigned int *)((&__WAKEUP_PSC_PDSTAT_BASE+(0x4*(\pd_id)))+\address_offset))
	IF (((Data.Long(D:Var.VALUE(\pdstat))&0x1)==Var.VALUE(\pd_state))&&((Data.Long(D:Var.VALUE(\mdstat))&0x1F)==Var.VALUE(\md_state)))
	(
		PRINT "No change needed."
		PRINT ""
		Var.Assign \ret=0x1
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Wait for GOSTAT to clear
	WHILE ((Var.VALUE(\loop_cnt)<&__PSC_TIMEOUT)&&((Data.Long(D:((Var.VALUE(&__WAKEUP_PSC_PTSTAT)+Var.VALUE(\address_offset))))&(0x1<<Var.VALUE(\pd_id)))!=0x0))
	(
		Var.Assign \loop_cnt=\loop_cnt+1
	)
	// --  Check if we got timeout error while waiting
	Var.IF ((\loop_cnt)>=&__PSC_TIMEOUT)
	(
		PRINT "ERROR: Timeout. You are likely attempting to modify the Power Sleep Controller"
		PRINT ""
		PRINT "       across a voltage crossing which is currently powered off."
		PRINT ""
		PRINT "       Consult the CBASS connectivity diagram and the PSC IP dictionary for more"
		PRINT ""
		PRINT "       information."
		PRINT ""
		Var.Assign \ret=0x0
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Set PDCTL NEXT to new state
	Data.Set D:(Var.VALUE(\pdctl)) %Long ((Data.Long(D:Var.VALUE(\pdctl))&(~0x1))|Var.VALUE(\pd_state))
	Data.Set D:(Var.VALUE(\mdctl)) %Long ((Data.Long(D:Var.VALUE(\mdctl))&(~0x1F))|Var.VALUE(\md_state))
	Data.Set D:(((Var.VALUE(&__WAKEUP_PSC_PTCMD)+Var.VALUE(\address_offset)))) %Long (Data.Long(D:((Var.VALUE(&__WAKEUP_PSC_PTCMD)+Var.VALUE(\address_offset))))|(0x1<<(Var.VALUE(\pd_id))))
	Var.Assign \loop_cnt=0x0
	WHILE ((Var.VALUE(\loop_cnt)<&__PSC_TIMEOUT)&&((Data.Long(D:((Var.VALUE(&__WAKEUP_PSC_PTSTAT)+Var.VALUE(\address_offset))))&(0x1<<Var.VALUE(\pd_id)))!=0x0))
	(
		Var.Assign \loop_cnt=\loop_cnt+1
	)
	// --  Check if we got timeout error while waiting
	Var.IF ((\loop_cnt)>=&__PSC_TIMEOUT)
	(
		PRINT "Timeout Error. State not changed."
		PRINT ""
		Var.Assign \ret=0x0
		&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
		RETURN &__FUNCTION_RETURN_VALUE
	)
	// --  Verify power domain and module domain state got changed
	IF (((Data.Long(D:Var.VALUE(\pdstat))&0x1)==Var.VALUE(\pd_state))&&((Data.Long(D:Var.VALUE(\mdstat))&0x1F)==Var.VALUE(\md_state)))
	(
		PRINT "Power domain and module state changed successfully."
		PRINT ""
		Var.Assign \ret=0x1
	)
	IF ((Data.Long(D:Var.VALUE(\pdstat))&0x1)!=Var.VALUE(\pd_state))
	(
		PRINT "ERROR: PSC power domain state NOT changed!"
		PRINT ""
		Var.Assign \ret=0x0
	)
	IF ((Data.Long(D:Var.VALUE(\mdstat))&0x1F)!=Var.VALUE(\md_state))
	(
		PRINT "ERROR: module state NOT changed!"
		PRINT ""
		Var.Assign \ret=0x0
	)
	&__FUNCTION_RETURN_VALUE=Var.VALUE(\ret)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)
// -- GET Main PSC State function

Get_MAIN_PSC_State:
(
	PRIVATE &__VF0 &__VF1
	ENTRY &__VF0 &__VF1
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	
	Var.NEWLOCAL unsigned int \pd_id=&__VF0
	Var.NEWLOCAL unsigned int \md_id=&__VF1
	Var.NEWLOCAL unsigned int * \mdctl
	Var.NEWLOCAL unsigned int * \mdstat
	Var.NEWLOCAL unsigned int * \pdstat
	Var.NEWLOCAL unsigned int \pt_state
	Var.NEWLOCAL unsigned int \pd_state
	Var.NEWLOCAL unsigned int \md_state
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	IF (Data.Long(D:(&__MAIN_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x80000000
	)
	Var.Assign \mdstat=((unsigned int *)((&__MAIN_PSC_MDSTAT_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \pdstat=((unsigned int *)((&__MAIN_PSC_PDSTAT_BASE+(0x4*(\pd_id)))+\address_offset))
	Var.Assign \pt_state=(\Data_Long(((&__MAIN_PSC_PTSTAT+\address_offset)))&(0x1<<(\pd_id)))
	Var.Assign \pd_state=(\Data_Long(\pdstat)&0x1)
	Var.Assign \md_state=(\Data_Long(\mdstat)&0x1F)
	Var.IF ((\pd_state)==&__PSC_PD_OFF)
	(
		PRINT "Power Domain: Off"
		PRINT " "
	)
	ELSE
	(
		Var.IF ((\pd_state)==&__PSC_PD_ON)
		(
			PRINT "Power Domain: On"
			PRINT " "
		)
		ELSE
		(
			PRINT "Power Domain: ERR"
			PRINT " "
		)
	)
	Var.IF ((\md_state)==&__PSC_SYNCRESETDISABLE)
	(
		PRINT "Module State: SyncResetDiable"
		PRINT " "
	)
	ELSE
	(
		Var.IF ((\md_state)==&__PSC_SYNCRESET)
		(
			PRINT "Module State: SyncReset"
			PRINT " "
		)
		ELSE
		(
			Var.IF ((\md_state)==&__PSC_DISABLE)
			(
				PRINT "Module State: Disable"
				PRINT " "
			)
			ELSE
			(
				Var.IF ((\md_state)==&__PSC_ENABLE)
				(
					PRINT "Module State: Enable"
					PRINT " "
				)
				ELSE
				(
					PRINT "Module State: Error"
					PRINT " "
				)
			)
		)
	)
	&__FUNCTION_RETURN_VALUE=Var.VALUE(0x1)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)
// -- Get WKUP PSC STATE

Get_WKUP_PSC_State:
(
	PRIVATE &__VF0 &__VF1
	ENTRY &__VF0 &__VF1
	
	&__VF0=&__VF0 // evaluation of passed expressions 
	&__VF1=&__VF1
	
	Var.NEWLOCAL unsigned int \pd_id=&__VF0
	Var.NEWLOCAL unsigned int \md_id=&__VF1
	Var.NEWLOCAL unsigned int * \mdctl
	Var.NEWLOCAL unsigned int * \mdstat
	Var.NEWLOCAL unsigned int * \pdstat
	Var.NEWLOCAL unsigned int \pt_state
	Var.NEWLOCAL unsigned int \pd_state
	Var.NEWLOCAL unsigned int \md_state
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	Var.Assign \mdstat=((unsigned int *)((&__WAKEUP_PSC_MDSTAT_BASE+(0x4*(\md_id)))+\address_offset))
	Var.Assign \pdstat=((unsigned int *)((&__WAKEUP_PSC_PDSTAT_BASE+(0x4*(\pd_id)))+\address_offset))
	Var.Assign \pt_state=(\Data_Long(((&__WAKEUP_PSC_PTSTAT+\address_offset)))&(0x1<<(\pd_id)))
	Var.Assign \pd_state=(\Data_Long(\pdstat)&0x1)
	Var.Assign \md_state=(\Data_Long(\mdstat)&0x1F)
	Var.IF ((\pd_state)==&__PSC_PD_OFF)
	(
		PRINT "Power Domain: Off"
		PRINT ""
	)
	ELSE
	(
		Var.IF ((\pd_state)==&__PSC_PD_ON)
		(
			PRINT "Power Domain: On"
			PRINT ""
		)
		ELSE
		(
			PRINT "Power Domain: ERR"
			PRINT ""
		)
	)
	Var.IF ((\md_state)==&__PSC_SYNCRESETDISABLE)
	(
		PRINT "Module State: SyncResetDiable"
		PRINT " "
	)
	ELSE
	(
		Var.IF ((\md_state)==&__PSC_SYNCRESET)
		(
			PRINT "Module State: SyncReset"
			PRINT " "
		)
		ELSE
		(
			Var.IF ((\md_state)==&__PSC_DISABLE)
			(
				PRINT "Module State: Disable"
				PRINT " "
			)
			ELSE
			(
				Var.IF ((\md_state)==&__PSC_ENABLE)
				(
					PRINT "Module State: Enable"
					PRINT " "
				)
				ELSE
				(
					PRINT "Module State: Error"
					PRINT " "
				)
			)
		)
	)
	&__FUNCTION_RETURN_VALUE=Var.VALUE(0x1)
	RETURN &__FUNCTION_RETURN_VALUE
	RETURN
)

WKUP_GP_CORE_CTL_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x1
	PRINT "Powering up LPSC_WKUP_ALWAYSON"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUP_ALWAYSON &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V0
	Var.Assign (\status&=(&__V0))
	PRINT "Powering up LPSC_DMSC"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_DMSC &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V1
	Var.Assign (\status&=(&__V1))
	PRINT "Powering up LPSC_DEBUG2DMSC"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_DEBUG2DMSC &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V2
	Var.Assign (\status&=(&__V2))
	PRINT "Powering up LPSC_WKUP_GPIO"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUP_GPIO &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V3
	Var.Assign (\status&=(&__V3))
	PRINT "Powering up LPSC_WKUPMCU2MAIN"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUPMCU2MAIN &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V4
	Var.Assign (\status&=(&__V4))
	PRINT "Powering up LPSC_MAIN2WKUPMCU"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MAIN2WKUPMCU &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V5
	Var.Assign (\status&=(&__V5))
	PRINT "Powering up LPSC_MCU_TEST"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_TEST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V6
	Var.Assign (\status&=(&__V6))
	PRINT "Powering up LPSC_MCU_DEBUG"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_DEBUG &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V7
	Var.Assign (\status&=(&__V7))
	PRINT "Powering up LPSC_MCU_MCAN_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_MCAN_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V8
	Var.Assign (\status&=(&__V8))
	PRINT "Powering up LPSC_MCU_MCAN_1"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_MCAN_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V9
	Var.Assign (\status&=(&__V9))
	PRINT "Powering up LPSC_MCU_OSPI_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_OSPI_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V10
	Var.Assign (\status&=(&__V10))
	PRINT "Powering up LPSC_MCU_OSPI_1"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_OSPI_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V11
	Var.Assign (\status&=(&__V11))
	PRINT "Powering up LPSC_MCU_HYPERBUS"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_HYPERBUS &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V12
	Var.Assign (\status&=(&__V12))
	PRINT "Powering up LPSC_MCU_I3C_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_I3C_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V13
	Var.Assign (\status&=(&__V13))
	PRINT "Powering up LPSC_MCU_ADC_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_ADC_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V14
	Var.Assign (\status&=(&__V14))
	PRINT "Powering up LPSC_MCU_ADC_1"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_MCU_ADC_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V15
	Var.Assign (\status&=(&__V15))
	PRINT "Powering up LPSC_WKUP_SPARE_0 (HSM) "
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUP_SPARE_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V16
	Var.Assign (\status&=(&__V16))
	RETURN
)

WKUP_MCU_PULSAR_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- R5F
	PRINT "Powering up LPSC_MCU_R5_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_MCU_PULSAR &__LPSC_MCU_R5_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V17
	Var.Assign (\status&=(&__V17))
	PRINT "Powering up LPSC_MCU_R5_1"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_MCU_PULSAR &__LPSC_MCU_R5_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V18
	Var.Assign (\status&=(&__V18))
	PRINT "Powering up LPSC_MCU_PULSAR_PBIST_0"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_MCU_PULSAR &__LPSC_MCU_PULSAR_PBIST_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V19
	Var.Assign (\status&=(&__V19))
	RETURN
)
// --  This function will turn on: 
// -- 1. Main Always on
// -- 2. Main Test (DFT?)
// -- 3. Main PBIST
// -- 4. Audio
// -- 5. ATL
// -- 6. MLB
// -- 7. Motor
// -- 8. MiscIO (I2C, SPI, etc.)
// -- 9. GPMC
// -- 10. VPFE
// -- 11. VPE
// -- 12. Spare 0
// -- 13. Spare 1
// -- 14. Debug
// -- 15. DDR0
// -- 16. DDR1
// -- 17. Spare 2
// -- 18. CC_top_pbist
// -- 19. MMC4b 0
// -- 20. MMC4b 1
// -- 21. MMC8b 0

Main_GP_CORE_CTL_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_MAIN_ALWAYSON"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MAIN_ALWAYSON &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V20
	Var.Assign (\status&=(&__V20))
	PRINT "Powering up LPSC_MAIN_TEST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MAIN_TEST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V21
	Var.Assign (\status&=(&__V21))
	PRINT "Powering up LPSC_MAIN_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MAIN_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V22
	Var.Assign (\status&=(&__V22))
	PRINT "Powering up LPSC_PER_AUDIO"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_AUDIO &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V23
	Var.Assign (\status&=(&__V23))
	PRINT "Powering up LPSC_PER_ATL"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_ATL &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V24
	Var.Assign (\status&=(&__V24))
	PRINT "Powering up LPSC_PER_MLB"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_MLB &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V25
	Var.Assign (\status&=(&__V25))
	PRINT "Powering up LPSC_PER_MOTOR"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_MOTOR &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V26
	Var.Assign (\status&=(&__V26))
	PRINT "Powering up LPSC_PER_MISCIO"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_MISCIO &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V27
	Var.Assign (\status&=(&__V27))
	PRINT "Powering up LPSC_PER_GPMC"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_GPMC &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V28
	Var.Assign (\status&=(&__V28))
	PRINT "Powering up LPSC_PER_VPFE"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_VPFE &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V29
	Var.Assign (\status&=(&__V29))
	PRINT "Powering up LPSC_PER_VPE"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_VPE &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V30
	Var.Assign (\status&=(&__V30))
	PRINT "Powering up LPSC_PER_SPARE_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_SPARE_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V31
	Var.Assign (\status&=(&__V31))
	PRINT "Powering up LPSC_PER_SPARE_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_SPARE_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V32
	Var.Assign (\status&=(&__V32))
	PRINT "Powering up LPSC_MAIN_DEBUG"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MAIN_DEBUG &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V33
	Var.Assign (\status&=(&__V33))
	PRINT "Powering up LPSC_EMIF_CFG_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V34
	Var.Assign (\status&=(&__V34))
	PRINT "Powering up LPSC_EMIF_DATA_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V35
	Var.Assign (\status&=(&__V35))
	PRINT "Powering up LPSC_EMIF_CFG_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V36
	Var.Assign (\status&=(&__V36))
	PRINT "Powering up LPSC_EMIF_DATA_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V37
	Var.Assign (\status&=(&__V37))
	PRINT "Powering up LPSC_PER_SPARE_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_SPARE_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V38
	Var.Assign (\status&=(&__V38))
	PRINT "Powering up LPSC_MMC4B_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MMC4B_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V39
	Var.Assign (\status&=(&__V39))
	PRINT "Powering up LPSC_MMC4B_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MMC4B_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V40
	Var.Assign (\status&=(&__V40))
	PRINT "Powering up LPSC_MMC8B_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_MMC8B_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V41
	Var.Assign (\status&=(&__V41))
	PRINT "Powering up LPSC_SAUL"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_SAUL &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V42
	Var.Assign (\status&=(&__V42))
	PRINT "Powering up LPSC_PER_I3C"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PER_I3C &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V43
	Var.Assign (\status&=(&__V43))
	RETURN
)

Main_MCANSS_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- MCANSS
	PRINT "Powering up LPSC_MAIN_MCANSS_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V44
	Var.Assign (\status&=(&__V44))
	PRINT "Powering up LPSC_MAIN_MCANSS_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V45
	Var.Assign (\status&=(&__V45))
	PRINT "Powering up LPSC_MAIN_MCANSS_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V46
	Var.Assign (\status&=(&__V46))
	PRINT "Powering up LPSC_MAIN_MCANSS_3"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_3 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V47
	Var.Assign (\status&=(&__V47))
	PRINT "Powering up LPSC_MAIN_MCANSS_4"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_4 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V48
	Var.Assign (\status&=(&__V48))
	PRINT "Powering up LPSC_MAIN_MCANSS_5"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_5 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V49
	Var.Assign (\status&=(&__V49))
	PRINT "Powering up LPSC_MAIN_MCANSS_6"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_6 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V50
	Var.Assign (\status&=(&__V50))
	PRINT "Powering up LPSC_MAIN_MCANSS_7"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_7 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V51
	Var.Assign (\status&=(&__V51))
	PRINT "Powering up LPSC_MAIN_MCANSS_8"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_8 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V52
	Var.Assign (\status&=(&__V52))
	PRINT "Powering up LPSC_MAIN_MCANSS_9"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_9 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V53
	Var.Assign (\status&=(&__V53))
	PRINT "Powering up LPSC_MAIN_MCANSS_10"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_10 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V54
	Var.Assign (\status&=(&__V54))
	PRINT "Powering up LPSC_MAIN_MCANSS_11"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_11 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V55
	Var.Assign (\status&=(&__V55))
	PRINT "Powering up LPSC_MAIN_MCANSS_12"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_12 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V56
	Var.Assign (\status&=(&__V56))
	PRINT "Powering up LPSC_MAIN_MCANSS_13"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_MCANSS &__LPSC_MAIN_MCANSS_13 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V57
	Var.Assign (\status&=(&__V57))
	RETURN
)

Main_DSS_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- DSS
	PRINT "Powering up LPSC_DSS_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_DSS_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V58
	Var.Assign (\status&=(&__V58))
	PRINT "Powering up LPSC_DSS"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_DSS &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V59
	Var.Assign (\status&=(&__V59))
	PRINT "Powering up LPSC_TX_DPHY_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_TX_DPHY_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V60
	Var.Assign (\status&=(&__V60))
	PRINT "Powering up LPSC_DSI"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_DSI &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V61
	Var.Assign (\status&=(&__V61))
	PRINT "Powering up LPSC_EDP_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_EDP_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V62
	Var.Assign (\status&=(&__V62))
	PRINT "Powering up LPSC_CSITX_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_CSITX_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V63
	Var.Assign (\status&=(&__V63))
	PRINT "Powering up LPSC_CSIRX_PHY_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_CSIRX_PHY_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V64
	Var.Assign (\status&=(&__V64))
	PRINT "Powering up LPSC_CSIRX_PHY_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_CSIRX_PHY_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V65
	Var.Assign (\status&=(&__V65))
	PRINT "Powering up LPSC_CSIRX_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_CSIRX_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V66
	Var.Assign (\status&=(&__V66))
	PRINT "Powering up LPSC_CSIRX_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSS &__LPSC_CSIRX_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V67
	Var.Assign (\status&=(&__V67))
	PRINT "Powering up LPSC_CSITX_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSI_1 &__LPSC_CSITX_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V68
	Var.Assign (\status&=(&__V68))
	PRINT "Powering up LPSC_TX_DPHY_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSI_1 &__LPSC_TX_DPHY_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V69
	Var.Assign (\status&=(&__V69))
	PRINT "Powering up LPSC_DSI_1_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DSI_1 &__LPSC_DSI_1_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V70
	Var.Assign (\status&=(&__V70))
	RETURN
)

Main_ICSS_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- ICSSG
	PRINT "Powering up LPSC_ICSSG_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_ICSS &__LPSC_ICSSG_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V71
	Var.Assign (\status&=(&__V71))
	PRINT "Powering up LPSC_ICSSG_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_ICSS &__LPSC_ICSSG_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V72
	Var.Assign (\status&=(&__V72))
	RETURN
)

Main_9GSS_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- 9GSS
	PRINT "Powering up LPSC_9GSS"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_9GSS &__LPSC_9GSS &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V73
	Var.Assign (\status&=(&__V73))
	RETURN
)

Main_CPSW_2_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_CPSW_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_CPSW_2 &__LPSC_CPSW_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V74
	Var.Assign (\status&=(&__V74))
	RETURN
)

Main_PCIe_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- PCIe
	// -- 	GEL_TextOut("Powering up LPSC_PCIe_0\n");
	// -- 	status &= Set_MAIN_PSC_State( PD_GP_CORE_CTRL, LPSC_PCIE_0, PSC_PD_ON, PSC_ENABLE);
	PRINT "Powering up LPSC_PCIe_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_PCIE_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V75
	Var.Assign (\status&=(&__V75))
	RETURN
)

Main_SERDES_0_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- SERDES
	PRINT "Powering up LPSC_SERDES_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_0 &__LPSC_SERDES_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V76
	Var.Assign (\status&=(&__V76))
	RETURN
)

Main_SERDES_1_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_SERDES_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_1 &__LPSC_SERDES_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V77
	Var.Assign (\status&=(&__V77))
	RETURN
)

Main_SERDES_2_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_SERDES_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_2 &__LPSC_SERDES_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V78
	Var.Assign (\status&=(&__V78))
	RETURN
)

Main_SERDES_3_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_SERDES_3"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_3 &__LPSC_SERDES_3 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V79
	Var.Assign (\status&=(&__V79))
	RETURN
)

Main_SERDES_4_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_SERDES_4"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_4 &__LPSC_SERDES_4 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V80
	Var.Assign (\status&=(&__V80))
	RETURN
)

Main_SERDES_5_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_SERDES_5"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_SERDES_5 &__LPSC_SERDES_5 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V81
	Var.Assign (\status&=(&__V81))
	RETURN
)

Main_USB_Hyperlink_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	PRINT "Powering up LPSC_USB_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_USB_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V82
	Var.Assign (\status&=(&__V82))
	PRINT "Powering up LPSC_USB_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_USB_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V83
	Var.Assign (\status&=(&__V83))
	PRINT "Powering up LPSC_USB_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_USB_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V84
	Var.Assign (\status&=(&__V84))
	RETURN
)

Main_Timer_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- DMTimer
	PRINT "Powering up LPSC_DMTIMER_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_TIMER &__LPSC_DMTIMER_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V85
	Var.Assign (\status&=(&__V85))
	PRINT "Powering up LPSC_DMTIMER_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_TIMER &__LPSC_DMTIMER_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V86
	Var.Assign (\status&=(&__V86))
	PRINT "Powering up LPSC_DMTIMER_2"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_TIMER &__LPSC_DMTIMER_2 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V87
	Var.Assign (\status&=(&__V87))
	PRINT "Powering up LPSC_DMTIMER_3"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_TIMER &__LPSC_DMTIMER_3 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V88
	Var.Assign (\status&=(&__V88))
	PRINT "Powered up all Main Timers."
	PRINT ""
	RETURN
)

Main_UFS_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- UFS
	PRINT "Powering up LPSC_UFS_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_UFS_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V89
	Var.Assign (\status&=(&__V89))
	PRINT "Powering up LPSC_UFS_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_UFS_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V90
	Var.Assign (\status&=(&__V90))
	RETURN
)

C71_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- C7x
	PRINT "Powering up LPSC_C71X_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_C71X_0 &__LPSC_C71X_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V91
	Var.Assign (\status&=(&__V91))
	PRINT "Powering up LPSC_C71X_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_C71X_1 &__LPSC_C71X_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V92
	Var.Assign (\status&=(&__V92))
	PRINT "Powering up LPSC_C71X_0_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_C71X_0 &__LPSC_C71X_0_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V93
	Var.Assign (\status&=(&__V93))
	PRINT "Powering up LPSC_C71X_1_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_C71X_0 &__LPSC_C71X_1_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V94
	Var.Assign (\status&=(&__V94))
	RETURN
)

A72_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- A72
	PRINT "Powering up LPSC_A72_CLUSTER_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_A72_CLUSTER_0 &__LPSC_A72_CLUSTER_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V95
	Var.Assign (\status&=(&__V95))
	PRINT "Powering up LPSC_A72_CLUSTER_0_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_A72_CLUSTER_0 &__LPSC_A72_CLUSTER_0_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V96
	Var.Assign (\status&=(&__V96))
	PRINT "Powering up LPSC_A72_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_A72_0 &__LPSC_A72_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V97
	Var.Assign (\status&=(&__V97))
	PRINT "Powering up LPSC_A72_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_A72_1 &__LPSC_A72_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V98
	Var.Assign (\status&=(&__V98))
	RETURN
)

GPU_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- GPU
	PRINT "Powering up LPSC_GPUCOM"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GPUCOM &__LPSC_GPUCOM &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V99
	Var.Assign (\status&=(&__V99))
	PRINT "Powering up LPSC_GPUPBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GPUCOM &__LPSC_GPUPBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V100
	Var.Assign (\status&=(&__V100))
	PRINT "Powering up LPSC_GPUCORE"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GPUCORE &__LPSC_GPUCORE &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V101
	Var.Assign (\status&=(&__V101))
	RETURN
)

Main_Pulsar_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- MAIN SoC R5F 0
	PRINT "Powering up LPSC_PULSAR_0_R5_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_0 &__LPSC_PULSAR_0_R5_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V102
	Var.Assign (\status&=(&__V102))
	PRINT "Powering up LPSC_PULSAR_0_R5_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_0 &__LPSC_PULSAR_0_R5_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V103
	Var.Assign (\status&=(&__V103))
	PRINT "Powering up LPSC_PULSAR_0_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_0 &__LPSC_PULSAR_0_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V104
	Var.Assign (\status&=(&__V104))
	PRINT "Powering up LPSC_PULSAR_1_R5_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_1 &__LPSC_PULSAR_1_R5_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V105
	Var.Assign (\status&=(&__V105))
	PRINT "Powering up LPSC_PULSAR_1_R5_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_1 &__LPSC_PULSAR_1_R5_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V106
	Var.Assign (\status&=(&__V106))
	PRINT "Powering up LPSC_PULSAR_1_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_PULSAR_1 &__LPSC_PULSAR_1_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V107
	Var.Assign (\status&=(&__V107))
	RETURN
)

PD_Decoder_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- Decode
	PRINT "Powering up LPSC_DECODE_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DECODE &__LPSC_DECODE_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V108
	Var.Assign (\status&=(&__V108))
	PRINT "Powering up LPSC_DECODE_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DECODE &__LPSC_DECODE_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V109
	Var.Assign (\status&=(&__V109))
	RETURN
)

PD_Encoder_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- Encode
	// --     GEL_TextOut("Powering up LPSC_ENCODE_0\n");
	// --     status &= Set_MAIN_PSC_State( PD_ENCODE, LPSC_ENCODE_0, PSC_PD_ON, PSC_ENABLE);
	// -- 	GEL_TextOut("Powering up LPSC_ENCODE_PBIST\n");
	// --     status &= Set_MAIN_PSC_State( PD_ENCODE, LPSC_ENCODE_PBIST, PSC_PD_ON, PSC_ENABLE);
	// -- Additions for J7Quad
	PRINT "Powering up LPSC_ENCODE_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_ENCODE_1 &__LPSC_ENCODE_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V110
	Var.Assign (\status&=(&__V110))
	PRINT "Powering up LPSC_ENCODE_1_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_ENCODE_1 &__LPSC_ENCODE_1_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V111
	Var.Assign (\status&=(&__V111))
	RETURN
)

PD_DMPAC_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- DMPAC
	PRINT "Powering up LPSC_DMPAC"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DMPAC &__LPSC_DMPAC &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V112
	Var.Assign (\status&=(&__V112))
	PRINT "Powering up LPSC_SDE"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DMPAC &__LPSC_SDE &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V113
	Var.Assign (\status&=(&__V113))
	PRINT "Powering up LPSC_DMPAC_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_DMPAC &__LPSC_DMPAC_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V114
	Var.Assign (\status&=(&__V114))
	RETURN
)

PD_VPAC_PowerUp:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x0
	// -- VPAC
	PRINT "Powering up LPSC_VPAC"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_VPAC &__LPSC_VPAC &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V115
	Var.Assign (\status&=(&__V115))
	PRINT "Powering up LPSC_VPAC_PBIST"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_VPAC &__LPSC_VPAC_PBIST &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V116
	Var.Assign (\status&=(&__V116))
	RETURN
)
// -- * Internal function to turn on the WKUPMCU2MAIN bridge, in order to allow for
// -- * the DMSC to access MMRs and IPs in the Main SoC after initializing the RAT.

Turn_On_LPSC_WKUPMCU2MAIN:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x1
	PRINT "Powering up LPSC_WKUPMCU2MAIN"
	PRINT ""
	GOSUB Set_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUPMCU2MAIN &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V117
	Var.Assign (\status&=(&__V117))
	PRINT "Checking LPSC_WKUPMCU2MAIN"
	PRINT ""
	GOSUB Get_WKUP_PSC_State &__PD_GP_CORE_CTL_WKUP &__LPSC_WKUPMCU2MAIN
	ENTRY &__V118
	Var.Assign (\status&=(&__V118))
	RETURN
)
// --  Internal function to reset the DDR interface. 

Reset_DDR0:
(
	Var.NEWLOCAL int \status
	Var.Assign \status=0x1
	// -- Reset the DDR interface.
	PRINT "Reset LPSC_EMIF_CFG_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_0 &__PSC_PD_ON &__PSC_SYNCRESET
	ENTRY &__V119
	Var.Assign (\status&=(&__V119))
	PRINT "Reset LPSC_EMIF_DATA_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_0 &__PSC_PD_ON &__PSC_SYNCRESET
	ENTRY &__V120
	Var.Assign (\status&=(&__V120))
	PRINT "Reset LPSC_EMIF_CFG_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_1 &__PSC_PD_ON &__PSC_SYNCRESET
	ENTRY &__V121
	Var.Assign (\status&=(&__V121))
	PRINT "Reset LPSC_EMIF_DATA_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_1 &__PSC_PD_ON &__PSC_SYNCRESET
	ENTRY &__V122
	Var.Assign (\status&=(&__V122))
	PRINT "Powering up LPSC_EMIF_CFG_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V123
	Var.Assign (\status&=(&__V123))
	PRINT "Powering up LPSC_EMIF_DATA_0"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_0 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V124
	Var.Assign (\status&=(&__V124))
	PRINT "Powering up LPSC_EMIF_CFG_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_CFG_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V125
	Var.Assign (\status&=(&__V125))
	PRINT "Powering up LPSC_EMIF_DATA_1"
	PRINT ""
	GOSUB Set_MAIN_PSC_State &__PD_GP_CORE_CTRL &__LPSC_EMIF_DATA_1 &__PSC_PD_ON &__PSC_ENABLE
	ENTRY &__V126
	Var.Assign (\status&=(&__V126))
	RETURN
)

change_HSM_M4_LRST:
(
	PRIVATE &__VF0
	ENTRY &__VF0
	
	&__VF0=&__VF0 // evaluation of passed expression 
	
	Var.NEWLOCAL int \enable=&__VF0
	Var.NEWLOCAL unsigned int * \mdctl
	Var.NEWLOCAL unsigned int \loop_cnt
	Var.Assign \loop_cnt=0x0
	Var.NEWLOCAL unsigned int \ret
	Var.Assign \ret=0x1
	Var.NEWLOCAL unsigned int * \mdstat
	Var.NEWLOCAL unsigned int \mdstat_lrstz
	Var.Assign \mdstat_lrstz=0x0
	Var.NEWLOCAL unsigned int \address_offset
	Var.Assign \address_offset=0x0
	IF (Data.Long(D:(&__WAKEUP_PSC_BASE))!=&__PSC_PID)
	(
		Var.Assign \address_offset=0x20000000
	)
	// -- LPSC_HSM
	Var.Assign \mdctl=((unsigned int *)((&__WAKEUP_PSC_MDCTL_BASE+(0x4*&__LPSC_WKUP_SPARE_0))+\address_offset))
	Var.IF ((\enable)==0x1)
	(
		Data.Set D:(Var.VALUE(\mdctl)) %Long (Data.Long(D:Var.VALUE(\mdctl))&(~0x100))
	)
	ELSE
	(
		Data.Set D:(Var.VALUE(\mdctl)) %Long (Data.Long(D:Var.VALUE(\mdctl))|0x100)
	)
	Var.Assign \mdstat=((unsigned int *)((&__WAKEUP_PSC_MDSTAT_BASE+(0x4*&__LPSC_WKUP_SPARE_0))+\address_offset))
	Var.Assign \mdstat_lrstz=((\Data_Long(\mdstat)>>0x8)&0x1)
	Var.IF ((\mdstat_lrstz)==0x1)
	(
		PRINT "LPSC_HSM: Local Reset Released"
		PRINT ""
	)
	ELSE
	(
		PRINT "LPSC_HSM: Local Reset Asserted"
		PRINT ""
	)
	RETURN
)

__GeL_MeNu_CrEaTe:
(
	MENU.ReProgram
	(
		ADD
		MENU
		(
			POPUP "GEL"
			(
				POPUP "Power Sleep Controller/Common PSC Power Controls"
				(
					MENUITEM "Set_PSC_All_On" 
					(
						DO "&path_J7AEP_PSC_cmm" Set_PSC_All_On
					)
				)
			)
		)
	)
	RETURN
)

Set_PSC_All_On:
(
	PRINT "Powering up all PSC power domains in progress..."
	PRINT ""
	GOSUB WKUP_GP_CORE_CTL_PowerUp
	GOSUB WKUP_MCU_PULSAR_PowerUp
	GOSUB Main_GP_CORE_CTL_PowerUp
	GOSUB Main_SERDES_0_PowerUp
	GOSUB Main_MCANSS_PowerUp
	GOSUB Main_DSS_PowerUp
	GOSUB Main_PCIe_PowerUp
	GOSUB Main_Timer_PowerUp
	GOSUB Main_USB_Hyperlink_PowerUp
	GOSUB C71_PowerUp
	GOSUB A72_PowerUp
	GOSUB GPU_PowerUp
	GOSUB Main_Pulsar_PowerUp
	GOSUB PD_Encoder_PowerUp
	GOSUB PD_DMPAC_PowerUp
	GOSUB PD_VPAC_PowerUp
	GOSUB Main_CPSW_2_PowerUp
	PRINT "Powering up all PSC power domains done!"
	PRINT ""
	RETURN
	
)
